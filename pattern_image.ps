%!PS-Adobe-2.0 EPSF-1.2
%%Title:
%%Creator:Glen Newtopn
%%BoundingBox:0 0 400 400
%%%%%%%%%%%%%% 
<< /AllowTransparency true >> % enable transparency

/Shape{
    newpath
    50 75 moveto
    100 0 rlineto
    100 100 rlineto
    -100 -50 rlineto
    -100 50 rlineto
    closepath
}def


/Circle{
    0 0 50 0 360 arc closepath
}def
    


newpath
100 100 translate

gsave
%Shape
% Circle
% 3 setlinewidth
% 1 0 0 setrgbcolor
% stroke
% grestore



100{
    Shape
    %Circle
    pathbbox
    .1 .setstrokeconstantalpha  % stroke opacity
    5 setlinewidth
    gsave
    0 1 0 setrgbcolor
    {
        newpath
        /y exch def
        /x exch def
        x  rand 30 mod add
        y  rand 30 mod add 
        moveto
    }
    {
        /y exch def
        /x exch def
        x rand 30 mod add
        y rand 30 mod add
        lineto
    }
    {
        /y3 exch def
        /x3 exch def
        /y2 exch def
        /x2 exch def
        /y1 exch def
        /x1 exch def
        x1  rand 30 mod add
        y1  rand 30 mod add 
        x2  rand 30 mod add
        y2  rand 30 mod add 
        x3  rand 30 mod add
        y3  rand 30 mod add 
        curveto
    }
    {closepath stroke newpath} pathforall 
    grestore
}repeat

.5 .5 scale
newpath
10 40 moveto
100 100 50 50 150 150 rcurveto
45 rotate
100 100 50 50 150 150 rcurveto


fill
showpage

quit

(sort.ps) run

%/Rotate 77 def
/Rotate 0 def

/PixelMinDist 10 def
%/Rotate 0 def
%/Rotate 60 def
/Debug false def
/debug{
    Debug{
	(--- [ Debug) =
	===
	(--- ] Debug) =
    }{
	pop
    }ifelse
}def

41341734 srand


/GaussingBlur_KernelMatrix_3
<<
    /Matrix [
        1 2 1
        2 4 2
        1 2 1
    ]
    /Normalize true
    /NormalizeRange false 
>>def

/GaussingBlur_KernelMatrix_5
<<
    /Matrix [
        1  4  6  4 2
        4 16 24 16 4
        6 24 36 24 6
        4 16 24 16 4
        1  4  6  4 2
    ]
    /Normalize true
    /NormalizeRange false 
>>def

/Emboss_KernelMatrix_3 [
    2 -1 0
    -1 1 1
    0  1 2
] def

/Sharpen_KernelMatrix_3
<<
    /Matrix [
        0 -1 0
        -1 4 -1
        0 -1 0 
    ]
    /Normalize false
    /NormalizeRange true
>>def

/Laplacian_KernelMatrix_3
<<
    /Matrix[
        0 -1 0
        -1 4 -1
        0 -1 0 
    ]
    /Normalize false
    /NormalizeRange true
>>def

/HighPass_KernelMatrix_3
<<
    /Matrix[
        -1 -1 -1
        -1 9 -1
        -1 -1 -1
    ]
    /Normalize false
    /NormalizeRange true
>>def




/LowPass_KernelMatrix_3
<<
    /Matrix[
        1 1 1
        1 8 1
        1 1 1
    ]
    /Normalize true
    /NormalizeRange false
>> def

/Edge_3
<<
    /Matrix[
        -1 -1 -1
        -1  8 -1
        -1 -1 -1
    ]
    /Normalize false
    /NormalizeRange true
>> def




% /str 1512 string def
% /bits 8 def

% /pattern{
%     /light exch def /dark exch def
%     /diff light dark sub def
%     7 7 bits [.1 0 0 .1 0 0]
%     {0 1 511 {str exch rand diff mod dark add put} for
%      str} bind image
% } def


% /makeTexture{
%     gsave % row
%     100 300 translate
%     .025 .025 scale
%     159{
% 	gsave
% 	113{
% 	    70 0 translate 0 255 pattern
% 	}repeat
% 	grestore
% 	0 50 translate
%     }repeat
    
%     grestore
% }def

% gsave
% makeTexture
% grestore

% gsave

% 0.9 .setfillconstantalpha % FILL opacity
% .5 .setstrokeconstantalpha  % stroke opacity

% 100 300 moveto
% 200 0 rlineto
% 0 200 rlineto
% -200 0 rlineto
% closepath
% 1 1 0 setrgbcolor
% fill

% grestore

% showpage

% gsave
% /w 933 def
% /str w string def
% .333 setgray
% 0 1 w 1 sub {str exch rand 255 mod put} for
% 128 128 true [.8 0 0 .8 0 0] {str} imagemask
% % 100 0 translate
% % .333 setgray
% % 100 100 true [.5 0 0 .5 0 0] {str} imagemask
% % 0 100 translate
% % .666 setgray
% % 100 100 true [.5 0 0 .5 0 0] {str} imagemask
% grestore
% showpage



% /sl 1000 def
% /str sl string def

% % A4
% % 1785 = 210mm = 8.5   595 = 
% % 2526 = 297mm = 8.5   842 = 


% /pattern2{
%     /light exch def /dark exch def
%     /diff light dark sub def
%     1785 2526 bits [3 0 0 3 0 0]
%     {0 1 sl 1 sub {str exch rand diff mod dark add put} for
%      str} bind image
% } def

% gsave
% 120 70 translate
% 150 220 pattern2
% grestore
% showpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555

/pathbboxAsPath{
    1 dict begin
    pathbbox
    /y1 exch def /x1 exch def /y0 exch def /x0 exch defw
    
    newpath
    x0 y0 moveto
    x1 y0 lineto
    x1 y1 lineto
    x0 y1 lineto
    closepath
    end
}def

/showbb{
    gsave
    (showbb) =
    pathbboxAsPath
    3 setlinewidth
    0 1 0 setrgbcolor
    stroke
    grestore
    
}def

/centerOfMass{
    pathbbox
    /y1 exch def
    /x1 exch def
    /y0 exch def
    /x0 exch def

    y1 y0 add 2 div
    x1 x0 add 2 div
}def

/drawCenterOfMass{
    centerOfMass

    /x exch def
    /y exch def
    gsave
    1 0 0 setrgbcolor
    x y 10 dot
    grestore
}def

/cross{
    2 dict begin
    /s exch def
    gsave
    newpath
    0 s neg moveto
    0 s lineto
    s neg 0 moveto
    s 0 lineto

    stroke
    grestore

    end
}def
/showbb2{

    pathbbox
    /y0 exch def
    /x0 exch def
    /y1 exch def
    /x1 exch def

    gsave
    x0 y0 translate
    10 cross
    grestore

    gsave
    x0 y1 translate
    10 cross
    grestore

    gsave
    x1 y1 translate
    10 cross
    grestore

    gsave
    x1 y0 translate
    10 cross
    grestore    

}def



% /fill2{
%     fill
% }def

% gsave
% 100 0 translate
% 100 100 moveto
% 100 200 rlineto
% -100 100 rlineto
% -100 -200 rlineto
% closepath
% showbb
% gsave
% stroke
% grestore



% clipsave
% %pathbboxAsPath
% clip

% 0.8 .setfillconstantalpha % FILL opacity
% .5 .setstrokeconstantalpha  % stroke opacity

% 0 80 pattern2


% 0 1 0 setrgbcolor
% gsave
% fill2
% grestore

% 0 0 1 setrgbcolor


% newpath
% 20 20 moveto
% 180 170 rlineto
% -50 50 rlineto
% closepath
% fill

% newpath

% fill
% stroke


% %clip







% grestore
% showpage

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 150 200 pattern2
% showpage

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% /fillTexture{ % path
%     % pattern0 pattern1 fillAlpha
%     /alpha exch def
%     /p1 exch def
%     /p0 exch def
%     gsave
%     gsave
%     clip
%     p0 p1 pattern2
%     grestore
%     alpha .setfillconstantalpha % FILL opacity
%     fill
%     grestore
% }def


% newpath
% 100 100 moveto
% 50 0 rlineto
% 350 -50 rlineto
% 300 540 rlineto
% closepath
% gsave
% 0 0 1 setrgbcolor
% 0 200 .2 fillTexture
% grestore

% showbb


% showpage


% /noiseFillGray{
%     10 dict begin
    
%     /height exch def
%     /width exch def
%     /scale1 exch def
%     /maxGray exch def
%     /minGray exch def

%     width height gt{
% 	/size width def
%     }{
% 	/size height def
%     }ifelse
    
%     /stringLength size 13 mul 13 add def
%     /str stringLength  string def
    
%     /delta maxGray minGray sub def

%     % Image parameters:
%     size scale1 mul cvi     % width
%     size scale1 mul cvi     % height
%     8                       % bits/sample
%     [scale1 0 0 scale1 0 0] % matrix
%     {
% 	0 1 stringLength 1 sub
% 	{
% 	    str exch rand delta mod minGray add put
% 	} for
% 	str
%     }                      % datasrc
%     bind image % Image

%     end
% } def

 /z 500 def
% 100 100 translate
% newpath

% 0 0 moveto
% z 0 rlineto
% 0 z rlineto
% z neg 0 rlineto
% closepath
% 0 0 1 setrgbcolor
% .3 .setfillconstantalpha % FILL opacity

% gsave
% clip
% <<
%     /min 20
%     /max 190
%     /scale 1.5
%     /width z
%     /height z
% >>
% 20 190 1.5 z z noiseFillGray
% %20 230 3 z z pattern3

% grestore

% gsave
% %fill
% grestore
% stroke

% showpage

% /noiseFillColor{
%     10 dict begin
    
%     /height exch def
%     /width exch def
%     /scale1 exch def
%     /maxColor exch def
%     /minColor exch def

%     width height gt{
% 	/size width def
%     }{
% 	/size height def
%     }ifelse
    
%     /stringLength size 3 mul 3 add def
%     /str stringLength  string def
    
%     /delta maxColor minColor sub def

%     % Image parameters:
%     size scale1 mul cvi     % width
%     size scale1 mul cvi     % height
%     8                       % bits/sample
%     [scale1 0 0 scale1 0 0] % matrix
%     {
% 	0 3 stringLength 1 sub
% 	{
% 	    /n exch def
% 	    str n rand delta mod minColor add put
% 	    str n 1 add rand delta mod minColor add put
% 	    str n 2 add rand delta mod minColor add put
% 	} for
% 	str
%     }                      % datasrc
%     false
%     3
%     colorimage % Image

%     end
% } def

% 100 100 translate
% 20 190 1.5 z z noiseFillColor


% newpath

% 0 0 moveto
% z 0 rlineto
% 0 z rlineto
% z neg 0 rlineto
% closepath
% 0 0 1 setrgbcolor
% .5 .setfillconstantalpha % FILL opacity

% fill

% showpage


 /plusMinus{
    %add
    rand 2 mod 0 eq
    {
	add
    }{
	sub
    }ifelse
}def


/range{ % clamps the values to this range; <min becomes min; >max becomes max
    /max exch def
    /min exch def

    min max ge{
        (/range: min must be less than max) /rangeerror signalerror
    }if

    dup max gt{
	pop
	max
    }{
	dup min lt{
	    pop
	    min
	}if
    }ifelse

}bind def



% /noiseFillColorThisColor{
%     (HELLO) =    
%     10 dict begin
%     /height exch def
%     /width exch def
%     /scale1 exch def
    
%     /deltaPlusMinus exch def
%     /blue exch def
%     /green exch def
%     /red exch def


%     width height gt{
% 	/size width cvi def
%     }{
% 	/size height cvi def
%     }ifelse
    
%     /stringLength size 3 mul 3 add def
%     /str stringLength  string def

%     % Image parameters:
%     size scale1 mul cvi     % width
%     size scale1 mul cvi     % height
%     8                       % bits/sample
%     [scale1 0 0 scale1 0 0] % matrix
%     {

% 	0 3 stringLength 1 sub
% 	{
% 	    /n exch def
% 	    str n        red   rand deltaPlusMinus mod plusMinus  0 255 range  put
% 	    str n 1 add  green rand deltaPlusMinus mod plusMinus  0 255 range  put
% 	    str n 2 add  blue  rand deltaPlusMinus mod plusMinus  0 255 range  put
% 	} for
% 	str
%     }                      % datasrc
%     false
%     3
%     colorimage % Image

%     end
% } bind def

% 100 100 translate
% <<
%     /r 100
%     /g 10
%     /b 10
%     /deltaPlusMinus 50
%     /scale 2
%     /width z
%     /height z
%     >>

% 150 10 10 30   .4  z z noiseFillColorThisColor

% showpage


% gsave
% 0 setgray
% 50 50 translate
% newpath
% 0 0 moveto
% 100 0 rlineto
% 100 100 rlineto
% -100 100 rlineto
% closepath
% gsave
% stroke
% grestore

% pathbbox
% /y1 exch def
% /x1 exch def
% /y0 exch def
% /x0 exch def
% (bbox) =

% 150 10 10 30   .4  x1 x0 sub y1 y0 sub  noiseFillColorThisColor




% grestore
% showpage

% /noiseFillColorThisColorShape{ % path
%     pathbbox
%     /y1 exch def
%     /x1 exch def
%     /y0 exch def
%     /x0 exch def

%     x1 x0 sub =
%     y1 y0 sub =

%     gsave
%     clip
%     x1 x0 sub y1 y0 sub  noiseFillColorThisColor
%     grestore
% }bind def

% gsave
% 0 setgray
% 50 50 translate
% newpath
% 0 0 moveto
% 200 0 rlineto
% 100 200 rlineto
% 100 -20 rlineto
% -300 300 rlineto
% -30 100 rlineto
% closepath
% gsave
% stroke
% grestore

% gsave
% showbb
% grestore


% 150 10 10 30 3  noiseFillColorThisColorShape


% showpage

/pixelDist{
    /a exch def
    /b exch def

    a 0 get
    b 0 get
    sub dup mul

    a 1 get
    b 1 get
    sub dup mul

    a 2 get
    b 2 get
    sub dup mul

    add
    add
    sqrt
}def


/dot{
    1 dict begin
    /size exch def
    gsave
    translate
    newpath
    0 0 size 0 360 arc closepath fill
    grestore
    end
}bind def

/distanceToAbovePixelAboveLimit{
    /maxDist exch def
    n width 3 mul lt{
	true
    }{
	/abovePixel [
	    str n width 3 mul sub get
	    str n width 3 mul sub 1 add get
	    str n width 3 mul sub 2 add get
	] def
	v abovePixel pixelDist maxDist gt
    }ifelse
	
}def


/makeRandomColor{
    
    20{
     	/v [
     	.red   rand .deltaPlusMinus.R mod plusMinus  cvi 0 255 range
     	.green rand .deltaPlusMinus.G mod plusMinus  cvi 0 255 range
     	.blue  rand .deltaPlusMinus.B mod plusMinus  cvi 0 255 range
     	] def
	
     	v previousPixel pixelDist PixelMinDist gt
	PixelMinDist distanceToAbovePixelAboveLimit
	and
	{
	    /previousPixel v store
     	    exit
     	}if
     }repeat
     v
}bind def

/noiseFillColorThisColor2_MM{
    (noiseFillColorThisColor2: START) =
    10 dict begin
    /d# exch def

    /.color d# /Color get def

    /.x0 d# /X0 get def
    /.y0 d# /Y0 get def
    /.x1 d# /X1 get def
    /.y1 d# /Y1 get def
    /.scale d# /Scale get def

    d# /Interpolate known{
	/.interpolate d# /Interpolate get def
    }{
	/.interpolate false def
    }ifelse


    % Add 40 to buffer fill
    /width x1 x0 sub 50 add .scale mul cvi def
    /height y1 y0 sub 50 add .scale mul cvi def

    width =
    height =
    
    .color{
	/.blue d# /Blue get def
	/.green d# /Green get def
	/.red d# /Red get def
	/.deltaPlusMinus.R d# /DeltaPlusMinus.R get def
	/.deltaPlusMinus.G d# /DeltaPlusMinus.G get def
	/.deltaPlusMinus.B d# /DeltaPlusMinus.B get def
    }{
	/.gray d# /Gray get def
	/.deltaPlusMinus.Gray d# /DeltaPlusMinus.Gray get def
    }ifelse

    %/stringLength height width add 2 div dup mul 3 mul 3 add cvi def
    .color{
        /stringLength height width mul 3 mul  def
	/DeviceRGB setcolorspace
	/decode [0 1 0 1 0 1] def
    }{
	/DeviceGray setcolorspace
        /stringLength height width mul def
	/decode [0 1] def
    }ifelse

    %/stringLength width height mul 3 mul cvi def
    /str stringLength  string def

    gsave
    .x0 25 sub .y0 25 sub translate


    %/DeviceRGB setcolorspace
    {
    << % Start image dictionary
	/ImageType 1
	/Width width
	/Height height
	/BitsPerComponent 8
	/Interpolate .interpolate
	/Decode decode  % Decode color values in normal way
	/ImageMatrix [.scale 0 0 .scale 0 0]
	/DataSource
	{
	    (HELLO 999) =
	    /previousPixel [500 500 500] def
		.color{
		    0 3 stringLength  4 sub
		}{ 
		    0 1 stringLength 1 sub % grayscale
		}ifelse
		{

		    /n exch def
		    .color{
			/newPixel makeRandomColor def
			str n         newPixel 0 get    put %newPixel 0 get    put
			str n 1 add   newPixel 1 get    put
			str n 2 add   newPixel 2 get    put
		    }{
			% grayscale
			str n        .gray   rand .deltaPlusMinus.Gray mod plusMinus  0 255 range  put 
		    }ifelse
		} for
	    (NNN) =
	    d# /UseFilters get{
		    d# /Filters get ===
		    d# /Filters get{
			/f# exch def
			f# ===
			f# /UseThisFilter known =
			f# /UseThisFilter get{
			    (RUNNUNG) =
			    f# f# /FilterProc get exec
			    /str exch store
			}if
		    }forall
		    str
		    str str length 2 div cvi  get =
		    str str length 2 div cvi 1 add get =
		    str str length 2 div cvi 2 add get =
		}{
	        str
	    }ifelse
	} 
    >>
    image % Color Image
    }stopped{
	(ERROR - image) =
	$error /errorname get ===
	quit
    }if
    grestore
    end

} bind def


/colorPixel{
    2 dict begin
    /y exch def
    /x exch def

    %/iii y width mul    x  add 3 mul cvi def
    /iii width 3 mul y mul    x 3 mul add cvi def
    % () =
    % x =
    % y =
    % width =
    % height =
    % width 3 mul y mul =
    % iii =

    [
        str iii get 
        str iii 1 add get 
        str iii 2 add get
    ]
    end
}bind def


/kernel.Color.Average{
    % Not edges
    x d ge
    y d ge
    and
    x width d sub lt
    and
    y height d sub lt
    and
    {
        /valR 0 def
        /valG 0 def
        /valB 0 def
	/jj 0 def
	/ii 0 def
	/rgb null def

        d neg 1 d {
            /jj exch store
            d neg 1 d {
                /ii exch store
                /rgb x ii add y jj add  colorPixel store
                /valR valR  rgb 0 get  add store
                /valG valG  rgb 1 get  add  store
                /valB valB  rgb 2 get  add  store
            }for
        }for
        [
            valR cvr size2 cvr div cvi
            valG cvr size2 cvr div cvi
            valB cvr size2 cvr div cvi
        ]
    }{
	% Edge pixel
        [
            str i get
            str i 1 add get
            str i 2 add get
        ]
    }ifelse
}def

/kernel.Gray.Average{
    x d ge
    y d ge
    and
    x width d sub lt
    and
    y height d sub lt
    and
    {
        /sum 0 def
	/jj 0 def
	/ii 0 def

        d neg 1 d {
            /jj exch store
            d neg 1 d {

                /ii exch store

                /index    y jj add width mul    x add ii add def

                /sum sum str index get  add store
            }for
        }for

	sum size2 cvr div cvi % Return average
    }{
        str n get  % Return same value for edges
    }ifelse
}def


/kernel.Gray.Median{
    x d ge
    y d ge
    and
    x width d sub lt
    and
    y height d sub lt
    and
    {

        /mid size2 2.0 div ceiling cvi def
        /sum 0 def
        /values size2 array def
	/jj 0 def
	/ii 0 def

        /valuesIndex 0 def
        d neg 1 d {
            /jj exch store
            d neg 1 d {
                /ii exch store
                /index    y jj add width mul    x add ii add def
                values valuesIndex str index get put
                /valuesIndex valuesIndex 1 add store
                /sum sum str index get  add store
            }for
        }for
        values quicksort
        values mid get
    }{
        str n get  % Return same value for edges
    }ifelse
}def

/kernel.Gray.Generic{
    x d ge
    y d ge
    and
    x width d sub lt
    and
    y height d sub lt
    and
    {
        /sum 0 def

	/jj 0 def
	/ii 0 def
        /matrixIndex 0 def

        d neg 1 d {
            /jj exch store
            d neg 1 d {
                /ii exch store
                /index    y jj add width mul    x add ii add def

                /pixelValue  str index get def
                
                /sum sum   pixelValue .kernelMatrix matrixIndex get    mul add store
                /matrixIndex matrixIndex 1 add store
            }for
        }for

        .normalize{
            sum .matrixSum div cvi
        }{
            sum cvi
        }ifelse

        /vvv exch def

        vvv .zmin lt{
            /.zmin vvv store 
        }if

        vvv .zmax gt{
            /.zmax vvv store 
        }if
        vvv

    }{
        str n get  % Return same value for edges
    }ifelse
}def



/kernel.Color.SingleColor{
    kernelArgs# /Color get
}def

/kernel.Color.2Stripes{
    kernelArgs# /Vertical get{
	/axis x def
    }{
	/axis y def
    }ifelse
    
    axis .size mod .size 2 div lt{
	kernelArgs# /Color1 get
    }{
	kernelArgs# /Color2 get
    }ifelse
}def


/normalizeImageRange{
    () =
    (/normalizeImageRange START) =
    
    2 dict begin

    /normalizedImage newstr length string def
    
    /delta .zmax .zmin sub def
    0 1 newstr length 1 sub{
        /n exch def
         /v newstr n get def
         .zmin 0 lt{

             v .zmin sub cvr delta div 255 mul cvi 255 gt{
                 (QQUIT 1) =
                 quit
             }if
             normalizedImage n v .zmin abs add cvr delta div 255 mul cvi  put
         }{
             v .zmin sub cvr delta div 255 mul cvi 0 lt{
                 (QQUIT 2) =
                 (v=) =
                 v =
                 (.zmin =) =
                 .zmin =
                 (v .zmin sub = ) =
                 v .zmin sub =
                 quit
             }if
             normalizedImage n v .zmin add cvr delta div 255 mul cvi  put

         }ifelse
     }for


     normalizedImage
     end
}def

/sumMatrix{
    /sum 0 def
    {
        sum add /sum exch store
    }forall
    sum
}def

/filterHarness{
    (/filterharness START) =
    10 dict begin
    /ff# exch def
    /.zmax -99999 def
    /.zmin 99999 def
    
    /kernelArgs# ff# /KernelArgs# get def

    % Cache size for kernels that need it
    (================== nnnn) =
    ff# ===
    kernelArgs# ===

    /.normalizeRange false def
    /.normalize false def
    
    kernelArgs# /KernelMatrix known{
        kernelArgs# /Size   kernelArgs# /KernelMatrix get /Matrix get length sqrt cvi  put
        /.kernelMatrix   kernelArgs# /KernelMatrix get  /Matrix get def

        kernelArgs# /KernelMatrix get  /Normalize known{
            /.normalize kernelArgs# /KernelMatrix get  /Normalize get def
            /.matrixSum .kernelMatrix sumMatrix def
            .matrixSum =
        }if

        kernelArgs# /KernelMatrix get  /NormalizeRange known{
            /.normalizeRange kernelArgs# /KernelMatrix get  /NormalizeRange get def
        }if
        
    }if

    kernelArgs# ===
    
    kernelArgs# /Size known{
	/.size kernelArgs# /Size get def
	/size2 .size .size mul def
	/d .size 2 div cvi def
	(==================) =
    }if
    (IIII) =
    d =

    .normalizeRange{
        (NO 2) =
        /newstr str length array def
        
    }{
        (NO) =
        /newstr str length string def

    }ifelse

    (M) =

    /x 0 def
    /y 0 def
    /i 0 def

    /newPixel [1 2 3] def
    0 1 height 1 sub{
        /y exch store

        0 1 width 1 sub{
            /x exch store

	    .color{
		/i y width mul   x  add 3 mul cvi store
	    }{
		/i y width mul   x  add cvi store
	    }ifelse

            ff# /Kernel get exec /newPixel  exch store

	    .color{
		newstr i         newPixel 0 get put
		newstr i 1 add   newPixel 1 get put
		newstr i 2 add   newPixel 2 get put
	    }{
		newstr i  newPixel  put
	    }ifelse
        }for
    }for

    (MAX MIN) =
    .zmin =
    .zmax =

    .normalizeRange{
        (NORMALIZING) =
        normalizeImageRange
        %newstr
    }{
        newstr
    }ifelse
    end
}bind def


/noiseFillThisShape2{ % path defined
    (/noiseFillThisShape2) =
    1 dict begin
    /d# exch def
    d# /Angle known{
	d# /Angle get rotate
    }if
    showbb
    pathbbox
    /y1 exch cvi def
    /x1 exch cvi def
    /y0 exch cvi def
    /x0 exch cvi def

    d# /X0 x0 put
    d# /Y0 y0 put 
    d# /X1 x1 put
    d# /Y1 y1 put

    gsave
    clip
    d# noiseFillColorThisColor2_MM
    %d# noiseFillColorThisColor2
    grestore
    end
}bind def




10 10 translate
newpath
100 100 moveto
100 0 rlineto
100 100 rlineto
100 0 rlineto
0 200 rlineto
-100 100 rlineto
-134 -45 rlineto
-100 100 rlineto
closepath

 gsave
 % Rotate rotate
 % showbb
 grestore

% gsave
% stroke
% grestore


gsave



<<
    /UseFilters true
    /Angle Rotate
    /Interpolate true
    
    /Filters[
	<<
	    /UseThisFilter false
	    /Kernel{
		kernel.Color.SingleColor
	    }
	    /KernelArgs#
	    <<
		/Color [100 0 0]
	    >>
	    /FilterProc {
		filterHarness
	    }
	>>

	<<
	    /UseThisFilter false
	    /Kernel{
		kernel.Color.2Stripes
	    }
	    /KernelArgs#
	    <<
		/Size 2
		/Color1 [0 255 0 0]
		/Color2 [255 0  0]
		/Vertical true
	    >>
	    /FilterProc {
		filterHarness
	    }
	>>
	<<
	    /UseThisFilter false
	    /Kernel{
		kernel.Color.Average
	    }
	    /KernelArgs#
	    <<
		/Size 3
	    >>
	    /FilterProc {
		filterHarness
	    }
	>>
    ]
    /Scale .8
    /Color true
    /Red 128
    /Green 60
    /Blue 60
    /DeltaPlusMinus.R 40
    /DeltaPlusMinus.G 40
    /DeltaPlusMinus.B 40

>>

%noiseFillThisShape2

grestore

%showpage



10 setlinewidth
10 10 translate
newpath
100 100 moveto
100 0 rlineto
120 120 rlineto
100 0 rlineto

 100 100 rlineto
 -100 40 rlineto
 -100  200 rlineto
 -100 100 rlineto
 closepath
 gsave
% stroke
 grestore
gsave

/pixel{ %str w h
    5 dict begin
    /.j exch def
    /.i exch def
    /.h exch def
    /.w exch def
    /.str exch def

    .w .h mul .str length ne{
        (/pixel: Size error) /rangeerror signalerror
        }if

    .str .w .j mul .i add get
     end
}bind def



/averageKernel.Gray{ % Assumes str .w .h x y size from /averageFilterGray
    2 dict begin
    /d .size 2 div cvi def

    x d ge
    y d ge
    and
    x .w d sub lt
    and
    y .h d sub lt
    and
    {
        /val 0 def
        d neg 1 d{
            /j exch def
            d neg 1 d{
                /i exch def
                /val val   .str .w .h x i add y j add pixel add store
            }for
        }for
        val .size .size mul div cvi
    }{
        str .w .h x y pixel cvi
    }ifelse
    end
}def

/averageFilter.Gray{ % w h str size
    1 dict begin
    /.size exch def
    /.h exch def
    /.w exch def
    /.str exch def

    /newstr .str length string def

    0 1 .h 1 sub{
        /y exch def
        
         0 1 .w 1 sub{
             /x exch def
             newstr y .w mul x add
             averageKernel.Gray
             put
         }for
    }for
    
    newstr
    end
}bind def



<<
    /Angle Rotate
    /Interpolate false

    /UseFilters false
    /Filters[
	<<
	    /UseThisFilter true
	    /FilterProc {
		filterHarness
	    }
	    /Kernel{
		kernel.Gray.Generic
	    }
	    /KernelArgs#
	    <<
                % OK                 /KernelMatrix LowPass_KernelMatrix_3
                % OK                 /KernelMatrix HighPass_KernelMatrix_3 
                % OK                 /KernelMatrix Laplacian_KernelMatrix_3
                % OK                 /KernelMatrix Edge_3
                % OK/KernelMatrix Sharpen_KernelMatrix_3
                % OK
                /KernelMatrix      GaussingBlur_KernelMatrix_5
                % OK                 /KernelMatrix GaussingBlur_KernelMatrix_3
	    >>
	>>
        <<
	    /UseThisFilter false
	    /FilterProc {
		color.FilterHarness
	    }
	    /Kernel{
		kernel.Gray.Median
	    }
	    /KernelArgs#
	    <<
		/Size 3
	    >>
	>>
        
        <<
	    /UseThisFilter false
	    /FilterProc {
		color.FilterHarness
	    }
	    /Kernel{
	        kernel.Gray.Average
	    }
	    /KernelArgs#
	    <<
		/Size 3
	    >>
	>>
    ]

    /Color false
    /Gray 128
    /DeltaPlusMinus.Gray 140
    /Scale .9
>> noiseFillThisShape2
grestore

gsave

grestore

gsave
%showbb
grestore
% gsave
 .2 .setfillconstantalpha % FILL opacity
  0 1 0 setrgbcolor
  fill
  grestore
showpage

% gsave
% 0 1 1 setrgbcolor
% showbb
% grestore

% gsave
% 0 1 0 setrgbcolor stroke
% grestore

% gsave
% 2 setlinewidth
% 1 0 0 setrgbcolor
% showbb2
% grestore


showpage

% gsave
% newpath
% fill
% grestore
% showpage



% /z 400 def
% 100 100 translate
% newpath
% 0 0 moveto
% z 0 rlineto
% 0 z rlineto
% z neg 0 rlineto
% closepath
% gsave
% stroke
% grestore

% gsave
% <<
%     /UseFilters true
%     /Filters[
% 	<<
% 	    /Filter false
% 	    /Kernel{
% 		kernel.Color.Average
% 	    }
% 	    /FilterProc {
% 		11 color.FilterHarness
% 	    }
% 	>>
% 	<<
% 	    /Filter true
% 	    /FilterProc {
% 		3 color.FilterHarness
% 	    }
% 	>>

%     ]
	


%     /Color true
%     /Red 128
%     /Green 10
%     /Blue 10
%     /DeltaPlusMinus 100
%     /Scale .2
% >> noiseFillThisShape2
% grestore

% 2 setlinewidth
% 1 0 0 setrgbcolor
% showbb2



% showpage


% /test[
%     23 54 12 45 233 54 6 7 56.9 -88.4
% ]def

% test ===

% test quicksort ===

% /w 10000 def
% /h 10000 def

% /Y h array def

% 0 1 h 1 sub{
%     /i exch def

%     /X w array def
%     Y i X put
% }for
    
    

% /f 4000 def
% /foo  f f mul array def
% f =
% f f mul =

<<
    /ImageType (/string or /real)
    /width /int
>>



Shape
1 setlinejoin
0 0 1 setrgbcolor
% gsave
% .1 .setstrokeconstantalpha  % stroke opacity
% 2 setlinewidth
% stroke
% grestore


/alpha 0.2 def

5 1 11{
    /n exch def
    gsave
    alpha .setstrokeconstantalpha  % stroke opacity
    n setlinewidth
    stroke
    grestore
    /alpha alpha .01 sub store
}for

gsave
0.7 .setfillconstantalpha
1 0 0 setrgbcolor
fill
grestore

showpage





Shape

gsave
stroke
grestore
showpage


Shape
1 0 0 setrgbcolor

gsave
{%moveto Push x y; execute move
    (Moveto x y) =
    = =
}
{%lineto Push x y; execute line
    (Lineto x y) =
    = =
}
{%curveto Push x1 y1 x2 y2 x3 y3; execute curve
}
{%closepath Execute close
}
pathforall
grestore

stroke
showpage


gsave
2 2 scale
/Helvetica-Bold findfont 10 scalefont setfont

Shape
gsave
clip

newpath
/a {300 rand exch mod} def
/b {300 rand exch mod} def
/c {300 rand exch mod} def
/d {300 rand exch mod} def
/e {300 rand exch mod} def
/f {300 rand exch mod} def
/note {moveto (q) show} def

.5 setlinewidth
173417 srand
/Sonata findfont 10 scalefont setfont

.5 .setstrokeconstantalpha  
100{
    gsave
    128 rand 128 mod add 255.0 div   0 rand 255 mod 255.0 div   128 rand 128 mod add 255.0 div   setrgbcolor

 %   rand 30 mod rotate
    3 setlinewidth
    rand 1 setlinewidth
    %0 setlinewidth
    %  0 0 moveto
    a b moveto
    %10 {a b c d e f curveto} repeat
    10 {a b lineto} repeat

    gsave
    .1 .setstrokeconstantalpha
    4 setlinewidth
    stroke
    grestore


    grestore
}repeat
%{pop pop}{pop pop}{note note note}{} pathforall stroke

grestore

newpath
0 0 moveto
500 500 rlineto
stroke

100 100 translate
100 100 10 dot
fill



showpage


Shape
gsave
showbb
grestore

gsave
pathbbox
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def

newpath
x1 y1 moveto
10 10 rlineto
stroke
grestore

gsave
currentpoint =
grestore

gsave
stroke
grestore
gsave
drawCenterOfMass
grestore



showpage

grestore
grestore
newpath
100 100 translate
%0 1 0 setrgbcolor
50 100 10 dot
showpage



