%!PS-Adobe-2.0 EPSF-1.2
%%Title:
%%Creator:Glen Newtopn
%%BoundingBox:0 0 400 400
%%%%%%%%%%%%%% 
%<< /AllowTransparency true >> % enable transparency


/Rotate 0 def

/PixelMinDist 10 def
%/Rotate 0 def
%/Rotate 60 def
/Debug false def
/debug{
    Debug{
	(--- [ Debug) =
	===
	(--- ] Debug) =
    }{
	pop
    }ifelse
}def

41341734 srand


% /str 1512 string def
% /bits 8 def

% /pattern{
%     /light exch def /dark exch def
%     /diff light dark sub def
%     7 7 bits [.1 0 0 .1 0 0]
%     {0 1 511 {str exch rand diff mod dark add put} for
%      str} bind image
% } def


% /makeTexture{
%     gsave % row
%     100 300 translate
%     .025 .025 scale
%     159{
% 	gsave
% 	113{
% 	    70 0 translate 0 255 pattern
% 	}repeat
% 	grestore
% 	0 50 translate
%     }repeat
    
%     grestore
% }def

% gsave
% makeTexture
% grestore

% gsave

% 0.9 .setfillconstantalpha % FILL opacity
% .5 .setstrokeconstantalpha  % stroke opacity

% 100 300 moveto
% 200 0 rlineto
% 0 200 rlineto
% -200 0 rlineto
% closepath
% 1 1 0 setrgbcolor
% fill

% grestore

% showpage

% gsave
% /w 933 def
% /str w string def
% .333 setgray
% 0 1 w 1 sub {str exch rand 255 mod put} for
% 128 128 true [.8 0 0 .8 0 0] {str} imagemask
% % 100 0 translate
% % .333 setgray
% % 100 100 true [.5 0 0 .5 0 0] {str} imagemask
% % 0 100 translate
% % .666 setgray
% % 100 100 true [.5 0 0 .5 0 0] {str} imagemask
% grestore
% showpage



% /sl 1000 def
% /str sl string def

% % A4
% % 1785 = 210mm = 8.5   595 = 
% % 2526 = 297mm = 8.5   842 = 


% /pattern2{
%     /light exch def /dark exch def
%     /diff light dark sub def
%     1785 2526 bits [3 0 0 3 0 0]
%     {0 1 sl 1 sub {str exch rand diff mod dark add put} for
%      str} bind image
% } def

% gsave
% 120 70 translate
% 150 220 pattern2
% grestore
% showpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555

/pathbboxAsPath{
    pathbbox
    /y0 exch def
    /x0 exch def
    /y1 exch def
    /x1 exch def
    
    newpath
    x0 y0 moveto
    x1 y0 lineto
    x1 y1 lineto
    x0 y1 lineto
    closepath
}def

/showbb{
    gsave
    (showbb) =
    pathbboxAsPath
    3 setlinewidth
    0 1 0 setrgbcolor
    stroke
    grestore
    
}def


/cross{
    2 dict begin
    /s exch def
    gsave
    newpath
    0 s neg moveto
    0 s lineto
    s neg 0 moveto
    s 0 lineto

    stroke
    grestore

    end
}def
/showbb2{

    pathbbox
    /y0 exch def
    /x0 exch def
    /y1 exch def
    /x1 exch def

    gsave
    x0 y0 translate
    10 cross
    grestore

    gsave
    x0 y1 translate
    10 cross
    grestore

    gsave
    x1 y1 translate
    10 cross
    grestore

    gsave
    x1 y0 translate
    10 cross
    grestore    

}def



% /fill2{
%     fill
% }def

% gsave
% 100 0 translate
% 100 100 moveto
% 100 200 rlineto
% -100 100 rlineto
% -100 -200 rlineto
% closepath
% showbb
% gsave
% stroke
% grestore



% clipsave
% %pathbboxAsPath
% clip

% 0.8 .setfillconstantalpha % FILL opacity
% .5 .setstrokeconstantalpha  % stroke opacity

% 0 80 pattern2


% 0 1 0 setrgbcolor
% gsave
% fill2
% grestore

% 0 0 1 setrgbcolor


% newpath
% 20 20 moveto
% 180 170 rlineto
% -50 50 rlineto
% closepath
% fill

% newpath

% fill
% stroke


% %clip







% grestore
% showpage

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 150 200 pattern2
% showpage

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% /fillTexture{ % path
%     % pattern0 pattern1 fillAlpha
%     /alpha exch def
%     /p1 exch def
%     /p0 exch def
%     gsave
%     gsave
%     clip
%     p0 p1 pattern2
%     grestore
%     alpha .setfillconstantalpha % FILL opacity
%     fill
%     grestore
% }def


% newpath
% 100 100 moveto
% 50 0 rlineto
% 350 -50 rlineto
% 300 540 rlineto
% closepath
% gsave
% 0 0 1 setrgbcolor
% 0 200 .2 fillTexture
% grestore

% showbb


% showpage


% /noiseFillGray{
%     10 dict begin
    
%     /height exch def
%     /width exch def
%     /scale1 exch def
%     /maxGray exch def
%     /minGray exch def

%     width height gt{
% 	/size width def
%     }{
% 	/size height def
%     }ifelse
    
%     /stringLength size 13 mul 13 add def
%     /str stringLength  string def
    
%     /delta maxGray minGray sub def

%     % Image parameters:
%     size scale1 mul cvi     % width
%     size scale1 mul cvi     % height
%     8                       % bits/sample
%     [scale1 0 0 scale1 0 0] % matrix
%     {
% 	0 1 stringLength 1 sub
% 	{
% 	    str exch rand delta mod minGray add put
% 	} for
% 	str
%     }                      % datasrc
%     bind image % Image

%     end
% } def

 /z 500 def
% 100 100 translate
% newpath

% 0 0 moveto
% z 0 rlineto
% 0 z rlineto
% z neg 0 rlineto
% closepath
% 0 0 1 setrgbcolor
% .3 .setfillconstantalpha % FILL opacity

% gsave
% clip
% <<
%     /min 20
%     /max 190
%     /scale 1.5
%     /width z
%     /height z
% >>
% 20 190 1.5 z z noiseFillGray
% %20 230 3 z z pattern3

% grestore

% gsave
% %fill
% grestore
% stroke

% showpage

% /noiseFillColor{
%     10 dict begin
    
%     /height exch def
%     /width exch def
%     /scale1 exch def
%     /maxColor exch def
%     /minColor exch def

%     width height gt{
% 	/size width def
%     }{
% 	/size height def
%     }ifelse
    
%     /stringLength size 3 mul 3 add def
%     /str stringLength  string def
    
%     /delta maxColor minColor sub def

%     % Image parameters:
%     size scale1 mul cvi     % width
%     size scale1 mul cvi     % height
%     8                       % bits/sample
%     [scale1 0 0 scale1 0 0] % matrix
%     {
% 	0 3 stringLength 1 sub
% 	{
% 	    /n exch def
% 	    str n rand delta mod minColor add put
% 	    str n 1 add rand delta mod minColor add put
% 	    str n 2 add rand delta mod minColor add put
% 	} for
% 	str
%     }                      % datasrc
%     false
%     3
%     colorimage % Image

%     end
% } def

% 100 100 translate
% 20 190 1.5 z z noiseFillColor


% newpath

% 0 0 moveto
% z 0 rlineto
% 0 z rlineto
% z neg 0 rlineto
% closepath
% 0 0 1 setrgbcolor
% .5 .setfillconstantalpha % FILL opacity

% fill

% showpage


 /plusMinus{
    %add
    rand 2 mod 0 eq
    {
	add
    }{
	sub
    }ifelse
}def


/range{ % clamps the values to this range; <min becomes min; >max becomes max
    /max exch def
    /min exch def

    min max ge{
        (/range: min must be less than max) /rangeerror signalerror
    }if

    dup max gt{
	pop
	max
    }{
	dup min lt{
	    pop
	    min
	}if
    }ifelse

}bind def



% /noiseFillColorThisColor{
%     (HELLO) =    
%     10 dict begin
%     /height exch def
%     /width exch def
%     /scale1 exch def
    
%     /deltaPlusMinus exch def
%     /blue exch def
%     /green exch def
%     /red exch def


%     width height gt{
% 	/size width cvi def
%     }{
% 	/size height cvi def
%     }ifelse
    
%     /stringLength size 3 mul 3 add def
%     /str stringLength  string def

%     % Image parameters:
%     size scale1 mul cvi     % width
%     size scale1 mul cvi     % height
%     8                       % bits/sample
%     [scale1 0 0 scale1 0 0] % matrix
%     {

% 	0 3 stringLength 1 sub
% 	{
% 	    /n exch def
% 	    str n        red   rand deltaPlusMinus mod plusMinus  0 255 range  put
% 	    str n 1 add  green rand deltaPlusMinus mod plusMinus  0 255 range  put
% 	    str n 2 add  blue  rand deltaPlusMinus mod plusMinus  0 255 range  put
% 	} for
% 	str
%     }                      % datasrc
%     false
%     3
%     colorimage % Image

%     end
% } bind def

% 100 100 translate
% <<
%     /r 100
%     /g 10
%     /b 10
%     /deltaPlusMinus 50
%     /scale 2
%     /width z
%     /height z
%     >>

% 150 10 10 30   .4  z z noiseFillColorThisColor

% showpage


% gsave
% 0 setgray
% 50 50 translate
% newpath
% 0 0 moveto
% 100 0 rlineto
% 100 100 rlineto
% -100 100 rlineto
% closepath
% gsave
% stroke
% grestore

% pathbbox
% /y1 exch def
% /x1 exch def
% /y0 exch def
% /x0 exch def
% (bbox) =

% 150 10 10 30   .4  x1 x0 sub y1 y0 sub  noiseFillColorThisColor




% grestore
% showpage

% /noiseFillColorThisColorShape{ % path
%     pathbbox
%     /y1 exch def
%     /x1 exch def
%     /y0 exch def
%     /x0 exch def

%     x1 x0 sub =
%     y1 y0 sub =

%     gsave
%     clip
%     x1 x0 sub y1 y0 sub  noiseFillColorThisColor
%     grestore
% }bind def

% gsave
% 0 setgray
% 50 50 translate
% newpath
% 0 0 moveto
% 200 0 rlineto
% 100 200 rlineto
% 100 -20 rlineto
% -300 300 rlineto
% -30 100 rlineto
% closepath
% gsave
% stroke
% grestore

% gsave
% showbb
% grestore


% 150 10 10 30 3  noiseFillColorThisColorShape


% showpage

/pixelDist{
    /a exch def
    /b exch def

    a 0 get
    b 0 get
    sub dup mul

    a 1 get
    b 1 get
    sub dup mul

    a 2 get
    b 2 get
    sub dup mul

    add
    add
    sqrt
}def




/distanceToAbovePixelAboveLimit{
    /maxDist exch def
    n width 3 mul lt{
	true
    }{
	/abovePixel [
	    str n width 3 mul sub get
	    str n width 3 mul sub 1 add get
	    str n width 3 mul sub 2 add get
	] def
	v abovePixel pixelDist maxDist gt
    }ifelse
	
}def


/makeRandomColor{
    
    20{
     	/v [
     	.red   rand .deltaPlusMinus.R mod plusMinus  cvi 0 255 range
     	.green rand .deltaPlusMinus.G mod plusMinus  cvi 0 255 range
     	.blue  rand .deltaPlusMinus.B mod plusMinus  cvi 0 255 range
     	] def
	
     	v previousPixel pixelDist PixelMinDist gt
	PixelMinDist distanceToAbovePixelAboveLimit
	and
	{
	    /previousPixel v store
     	    exit
     	}if
     }repeat
     v
}bind def

/noiseFillColorThisColor2_MM{
    (noiseFillColorThisColor2: START) =
    10 dict begin
    /d# exch def

    /.color d# /Color get def

    /.x0 d# /X0 get def
    /.y0 d# /Y0 get def
    /.x1 d# /X1 get def
    /.y1 d# /Y1 get def
    /.scale d# /Scale get def

    d# /Interpolate known{
	/.interpolate d# /Interpolate get def
    }{
	/.interpolate false def
    }ifelse


    % Add 40 to buffer fill
    /width x1 x0 sub 50 add .scale mul cvi def
    /height y1 y0 sub 50 add .scale mul cvi def
    
    .color{
	/.blue d# /Blue get def
	/.green d# /Green get def
	/.red d# /Red get def
	/.deltaPlusMinus.R d# /DeltaPlusMinus.R get def
	/.deltaPlusMinus.G d# /DeltaPlusMinus.G get def
	/.deltaPlusMinus.B d# /DeltaPlusMinus.B get def
    }{
	(MM) =
	/.gray d# /Gray get def
	(BB) =
	/.deltaPlusMinus.Gray d# /DeltaPlusMinus.Gray get def
	(BBbbb) =
    }ifelse

    width =
    height =

    %/stringLength height width add 2 div dup mul 3 mul 3 add cvi def
    .color{
        /stringLength height width mul 3 mul  def
	/DeviceRGB setcolorspace
	/decode [0 1 0 1 0 1] def
    }{
	/DeviceGray setcolorspace
        /stringLength height width mul def
	/decode [0 1] def
    }ifelse

    %/stringLength width height mul 3 mul cvi def
    /str stringLength  string def

    gsave
    .x0 25 sub .y0 25 sub translate


    %/DeviceRGB setcolorspace
    (HELLO 222) =
    {
    << % Start image dictionary
	/ImageType 1
	/Width width
	/Height height
	/BitsPerComponent 8
	/Interpolate .interpolate
	/Decode decode  % Decode color values in normal way
	/ImageMatrix [.scale 0 0 .scale 0 0]
	/DataSource
	{
	    (HELLO 999) =
	    /previousPixel [500 500 500] def
		.color{
		    0 3 stringLength  4 sub
		}{ 
		    0 1 stringLength 1 sub % grayscale
		}ifelse
		{

		    /n exch def
		    .color{
			/newPixel makeRandomColor def
			
			str n         newPixel 0 get    put %newPixel 0 get    put
			str n 1 add   newPixel 1 get    put
			str n 2 add   newPixel 2 get    put
		    }{
			% grayscale
			str n        .gray   rand .deltaPlusMinus.Gray mod plusMinus  0 255 range  put 
		    }ifelse
		} for
	    (NNN) =
	    d# /UseFilters get{
		    d# /Filters get ===
		    d# /Filters get{
			/f# exch def
			f# ===
			f# /UseThisFilter known =
			f# /UseThisFilter get{
			    (RUNNUNG) =
			    f# f# /FilterProc get exec
			    /str exch store
			}if
		    }forall
		    str
		    str str length 2 div cvi  get =
		    str str length 2 div cvi 1 add get =
		    str str length 2 div cvi 2 add get =
		}{
	        str
	    }ifelse
	} 
    >>
    image % Color Image
    }stopped{
	(ERROR - image) =
	$error /errorname get ===
	quit
    }if
    grestore
    end

} bind def


/colorPixel{
    2 dict begin
    /y exch def
    /x exch def

    %/iii y width mul    x  add 3 mul cvi def
    /iii width 3 mul y mul    x 3 mul add cvi def
    % () =
    % x =
    % y =
    % width =
    % height =
    % width 3 mul y mul =
    % iii =

    [
        str iii get 
        str iii 1 add get 
        str iii 2 add get
    ]
    end
}bind def


/kernel.Color.Average{
    % Not edges
    x d ge
    y d ge
    and
    x width d sub lt
    and
    y height d sub lt
    and
    {
        /valR 0 def
        /valG 0 def
        /valB 0 def
	/jj 0 def
	/ii 0 def
	/rgb null def

        d neg 1 d {
            /jj exch store
            d neg 1 d {
                /ii exch store
                /rgb x ii add y jj add  colorPixel store
                /valR valR  rgb 0 get  add store
                /valG valG  rgb 1 get  add  store
                /valB valB  rgb 2 get  add  store
            }for
        }for
        [
            valR cvr size2 cvr div cvi
            valG cvr size2 cvr div cvi
            valB cvr size2 cvr div cvi
        ]
    }{
	% Edge pixel
        [
            str i get
            str i 1 add get
            str i 2 add get
        ]
    }ifelse
}def

/kernel.Gray.Average{
    (/kernel.Gray.Average) =
    % Not edges
    ( w h) =
    width =
    height =
    ( x y) =
    x =
    y = 
    (-) =

    x d ge
    y d ge
    and
    x width d sub lt
    and
    y height d sub lt
    and
    (BNBB 99) =
    {
        /sum 0 def
	/jj 0 def
	/ii 0 def

        d neg 1 d {

            /jj exch store
            d neg 1 d {

                /ii exch store

                /index jj width mul x add ii add def
		(BNBB 1888) =
                /sum sum str index get  add store
            }for
        }for
	sum size2 cvr div cvi
    }{
	(BNBB 2) =
	% Edge pixel
        %str i get
	33
    }ifelse
}def

/kernel.Color.SingleColor{
    kernelArgs# /Color get
}def

/kernel.Color.2Stripes{
    kernelArgs# /Vertical get{
	/axis x def
    }{
	/axis y def
    }ifelse
    
    axis .size mod .size 2 div lt{
	kernelArgs# /Color1 get
    }{
	kernelArgs# /Color2 get
    }ifelse
}def



/color.FilterHarness{
    (/color.FilterHarness START) =
    10 dict begin
    /ff# exch def

    /kernelArgs# ff# /KernelArgs# get def

    % Cache size for kernels that need it
    (================== nnnn) =
    ff# ===
    kernelArgs# ===

    kernelArgs# /Size known{
	/.size kernelArgs# /Size get def
	/size2 .size .size mul def
	/d .size 2 div cvi def
	(==================) =
    }if
    (IIII) =
    d =
    /newstr str length string def

    /x 0 def
    /y 0 def
    /i 0 def

    /newPixel [1 2 3] def
    0 1 height 1 sub{
        /y exch store

        0 1 width 1 sub{
            /x exch store

	    .color{
		/i y width mul   x  add 3 mul cvi store
	    }{
		/i y width mul   x  add cvi store
	    }ifelse

            ff# /Kernel get exec /newPixel  exch store

	    .color{
		newstr i         newPixel 0 get put
		newstr i 1 add   newPixel 1 get put
		newstr i 2 add   newPixel 2 get put
	    }{
		newstr i 45 put
	    }ifelse
        }for
    }for

    newstr
    end
}bind def


/noiseFillThisShape2{ % path defined
    (/noiseFillThisShape2) =
    1 dict begin
    /d# exch def
    d# /Angle known{
	d# /Angle get rotate
    }if
    pathbbox
    /y1 exch cvi def
    /x1 exch cvi def
    /y0 exch cvi def
    /x0 exch cvi def

    d# /X0 x0 put
    d# /Y0 y0 put 
    d# /X1 x1 put
    d# /Y1 y1 put

    gsave
    clip
    d# noiseFillColorThisColor2_MM
    %d# noiseFillColorThisColor2
    grestore
    end
}bind def




10 10 translate
newpath
100 100 moveto
100 0 rlineto
100 100 rlineto
100 0 rlineto
0 200 rlineto
-100 100 rlineto
-134 -45 rlineto
-100 100 rlineto
closepath

 gsave
 % Rotate rotate
 % showbb
 grestore

% gsave
% stroke
% grestore


gsave



<<
    /UseFilters true
    /Angle Rotate
    /Interpolate true
    
    /Filters[
	<<
	    /UseThisFilter false
	    /Kernel{
		kernel.Color.SingleColor
	    }
	    /KernelArgs#
	    <<
		/Color [100 0 0]
	    >>
	    /FilterProc {
		color.FilterHarness
	    }
	>>

	<<
	    /UseThisFilter false
	    /Kernel{
		kernel.Color.2Stripes
	    }
	    /KernelArgs#
	    <<
		/Size 2
		/Color1 [0 255 0 0]
		/Color2 [255 0  0]
		/Vertical true
	    >>
	    /FilterProc {
		color.FilterHarness
	    }
	>>
	<<
	    /UseThisFilter false
	    /Kernel{
		kernel.Color.Average
	    }
	    /KernelArgs#
	    <<
		/Size 3
	    >>
	    /FilterProc {
		color.FilterHarness
	    }
	>>
    ]
    /Scale .8
    /Color true
    /Red 128
    /Green 60
    /Blue 60
    /DeltaPlusMinus.R 40
    /DeltaPlusMinus.G 40
    /DeltaPlusMinus.B 40

>>

%noiseFillThisShape2

grestore

%showpage




10 10 translate
newpath
100 100 moveto
100 0 rlineto
100 100 rlineto
100 0 rlineto
0 200 rlineto
-100 100 rlineto
closepath
gsave
stroke
grestore
gsave

/pixel{ %str w h
    5 dict begin
    /.j exch def
    /.i exch def
    /.h exch def
    /.w exch def
    /.str exch def

    .w .h mul .str length ne{
        (/pixel: Size error) /rangeerror signalerror
        }if

    .str .w .j mul .i add get
     end
}bind def



/averageKernel.Gray{ % Assumes str .w .h x y size from /averageFilterGray
    2 dict begin
    /d .size 2 div cvi def

    x d ge
    y d ge
    and
    x .w d sub lt
    and
    y .h d sub lt
    and
    {
        /val 0 def
        d neg 1 d{
            /j exch def
            d neg 1 d{
                /i exch def
                /val val   .str .w .h x i add y j add pixel add store
            }for
        }for
        val .size .size mul div cvi
    }{
        str .w .h x y pixel cvi
    }ifelse
    end
}def

/averageFilter.Gray{ % w h str size
    1 dict begin
    /.size exch def
    /.h exch def
    /.w exch def
    /.str exch def

    /newstr .str length string def

    0 1 .h 1 sub{
        /y exch def
        
         0 1 .w 1 sub{
             /x exch def
             newstr y .w mul x add
             averageKernel.Gray
             put
         }for
    }for
    
    newstr
    end
}bind def



<<
    /Angle Rotate
    /Interpolate false

    /UseFilters true
    /Filters[
	<<
	    /UseThisFilter true
	    /FilterProc {
		color.FilterHarness
	    }
	    /Kernel{
		%str width height 3  averageFilter.Gray
		kernel.Gray.Average
	    }
	    /KernelArgs#
	    <<
		/Size 3
	    >>
	>>
    ]

    /Color false
    /Gray 128
    /DeltaPlusMinus.Gray 40
    /Scale 2
>> noiseFillThisShape2
grestore

gsave
showbb
grestore
showpage

% gsave
% 0 1 1 setrgbcolor
% showbb
% grestore

% gsave
% 0 1 0 setrgbcolor stroke
% grestore

% gsave
% 2 setlinewidth
% 1 0 0 setrgbcolor
% showbb2
% grestore


showpage

% gsave
% newpath
% fill
% grestore
% showpage



% /z 400 def
% 100 100 translate
% newpath
% 0 0 moveto
% z 0 rlineto
% 0 z rlineto
% z neg 0 rlineto
% closepath
% gsave
% stroke
% grestore

% gsave
% <<
%     /UseFilters true
%     /Filters[
% 	<<
% 	    /Filter false
% 	    /Kernel{
% 		kernel.Color.Average
% 	    }
% 	    /FilterProc {
% 		11 color.FilterHarness
% 	    }
% 	>>
% 	<<
% 	    /Filter true
% 	    /FilterProc {
% 		3 color.FilterHarness
% 	    }
% 	>>

%     ]
	


%     /Color true
%     /Red 128
%     /Green 10
%     /Blue 10
%     /DeltaPlusMinus 100
%     /Scale .2
% >> noiseFillThisShape2
% grestore

% 2 setlinewidth
% 1 0 0 setrgbcolor
% showbb2



% showpage
