%!PS-Adobe-2.0 EPSF-1.2
%%Title:
%%Creator:Glen Newtopn
%%BoundingBox:0 0 400 400
%%%%%%%%%%%%%% 
<< /AllowTransparency true >> % enable transparency


/MaxInt 2147483647 def
/MaxIntAsReal MaxInt cvr def

/random.0_1{
    rand cvr MaxIntAsReal div
}def

/Shape{
    newpath
    50 75 moveto
    100 0 rlineto
    100 100 rlineto
    -100 -50 rlineto
    -100 50 rlineto
    closepath
}def


/Circle{
    0 0 50 0 360 arc closepath
}def
    


newpath
100 100 translate

gsave
%Shape
% Circle
% 3 setlinewidth
% 1 0 0 setrgbcolor
% stroke
% grestore



100{
    Shape
    pathbbox
    .1 .setstrokeconstantalpha  % stroke opacity
    5 setlinewidth
    gsave
    0 1 0 setrgbcolor
    {
        newpath
        /y exch def
        /x exch def
        x  rand 30 mod add
        y  rand 30 mod add 
        moveto
    }
    {
        /y exch def
        /x exch def
        x rand 30 mod add
        y rand 30 mod add
        lineto
    }
    {
        /y3 exch def
        /x3 exch def
        /y2 exch def
        /x2 exch def
        /y1 exch def
        /x1 exch def
        x1  rand 30 mod add
        y1  rand 30 mod add 
        x2  rand 30 mod add
        y2  rand 30 mod add 
        x3  rand 30 mod add
        y3  rand 30 mod add 
        curveto
    }
    {closepath stroke newpath} pathforall 
    grestore
}repeat

.5 .5 scale
newpath
10 40 moveto
100 100 50 50 150 150 rcurveto
45 rotate
100 100 50 50 150 150 rcurveto


fill
showpage



(sort.ps) run

%/Rotate 77 def
/Rotate 0 def

/PixelMinDist 10 def
%/Rotate 0 def
%/Rotate 60 def
/Debug false def
/debug{
    Debug{
	(--- [ Debug) =
	===
	(--- ] Debug) =
    }{
	pop
    }ifelse
}def

41341734 srand


/GaussingBlur_KernelMatrix_3
<<
    /Name (GaussingBlur_KernelMatrix_3) 
    /Matrix [
        1 2 1
        2 4 2
        1 2 1
    ]
    /Normalize true
    /NormalizeRange false 
>>def

/GaussingBlur_KernelMatrix_5
<<
    /Name (/GaussingBlur_KernelMatrix_5)
    /Matrix [
        1  4  6  4 2
        4 16 24 16 4
        6 24 36 24 6
        4 16 24 16 4
        1  4  6  4 2
    ]
    /Normalize true
    /NormalizeRange false 
>>def

/Emboss_KernelMatrix_3 [
    2 -1 0
    -1 1 1
    0  1 2
] def

/Sharpen_KernelMatrix_3
<<
    /Name (/Sharpen_KernelMatrix_3)
    /Matrix [
        0 -1 0
        -1 4 -1
        0 -1 0 
    ]
    /Normalize false
    /NormalizeRange true
>>def

/Laplacian_KernelMatrix_3
<<
    /Name (/Laplacian_KernelMatrix_3)
    /Matrix[
        0 -1 0
        -1 4 -1
        0 -1 0 
    ]
    /Normalize false
    /NormalizeRange true
>>def

/HighPass_KernelMatrix_3
<<
    /Name (/HighPass_KernelMatrix_3)
    /Matrix[
        -1 -1 -1
        -1 9 -1
        -1 -1 -1
    ]
    /Normalize false
    /NormalizeRange true
>>def




/LowPass_KernelMatrix_3
<<
    /Name (/LowPass_KernelMatrix_3)
    /Matrix[
        1 1 1
        1 8 1
        1 1 1
    ]
    /Normalize true
    /NormalizeRange false
>> def

/Edge_3
<<
    /Name (/Edge_3)
    /Matrix[
        -1 -1 -1
        -1  8 -1
        -1 -1 -1
    ]
    /Normalize false
    /NormalizeRange true
>> def





/bbox.AsPath{
    1 dict begin
    pathbbox
    /y1 exch def /x1 exch def /y0 exch def /x0 exch def
    
    newpath
    x0 y0 moveto
    x1 y0 lineto
    x1 y1 lineto
    x0 y1 lineto
    closepath
    end
}def

/bbox.Show{
    gsave
    (bbox.Show) =
    bbox.AsPath
    3 setlinewidth
    0 1 0 setrgbcolor
    stroke
    grestore
    
}def

/bbox.CenterOf{
    pathbbox
    /y1 exch def
    /x1 exch def
    /y0 exch def
    /x0 exch def

    y1 y0 add 2 div
    x1 x0 add 2 div
}def

/bbox.DrawCenterOf{
    bbox.CenterOf

    /x exch def
    /y exch def
    gsave
    1 0 0 setrgbcolor
    x y 10 dot
    grestore
}def

/cross{
    2 dict begin
    /s exch def
    gsave
    newpath
    0 s neg moveto
    0 s lineto
    s neg 0 moveto
    s 0 lineto

    stroke
    grestore

    end
}def

/bbox.Show2{
    pathbbox
    /y0 exch def
    /x0 exch def
    /y1 exch def
    /x1 exch def

    gsave
    x0 y0 translate
    10 cross
    grestore

    gsave
    x0 y1 translate
    10 cross
    grestore

    gsave
    x1 y1 translate
    10 cross
    grestore

    gsave
    x1 y0 translate
    10 cross
    grestore    

}def





 /plusMinus{
    %add
    rand 2 mod 0 eq
    {
	add
    }{
	sub
    }ifelse
}def


/range{ % clamps the values to this range; <min becomes min; >max becomes max
    /max exch def
    /min exch def

    min max ge{
        (/range: min must be less than max) /rangeerror signalerror
    }if

    dup max gt{
	pop
	max
    }{
	dup min lt{
	    pop
	    min
	}if
    }ifelse

}bind def



/rgb.Distance{
    /a exch def
    /b exch def

    a 0 get
    b 0 get
    sub dup mul

    a 1 get
    b 1 get
    sub dup mul

    a 2 get
    b 2 get
    sub dup mul

    add
    add
    sqrt
}def


/dot{
    1 dict begin
    /size exch def
    gsave
    translate
    newpath
    0 0 size 0 360 arc closepath fill
    grestore
    end
}bind def

/distanceToAbovePixelAboveLimit{
    /maxDist exch def
    n width 3 mul lt{
	true
    }{
	/abovePixel [
	    str n width 3 mul sub get
	    str n width 3 mul sub 1 add get
	    str n width 3 mul sub 2 add get
	] def
	v abovePixel rgb.Distance maxDist gt
    }ifelse
	
}def


/makeColorJitter{
    20{
     	/v [
     	    .red   rand .deltaPlusMinus.R mod plusMinus  cvi 0 255 range
     	    .green rand .deltaPlusMinus.G mod plusMinus  cvi 0 255 range
     	    .blue  rand .deltaPlusMinus.B mod plusMinus  cvi 0 255 range
     	] def
     	v previousPixel rgb.Distance PixelMinDist gt
	PixelMinDist distanceToAbovePixelAboveLimit
	and
	{
	    /previousPixel v store
     	    exit
     	}if
     }repeat
     v
}bind def

/image.source.RandomImage{
    	    (HELLO 999) =
	    /previousPixel [500 500 500] def
		.color{
		    0 3 stringLength  4 sub
		}{ 
		    0 1 stringLength 1 sub % grayscale
		}ifelse
		{

		    /n exch def
		    .color{
			/newPixel makeColorJitter def
			str n         newPixel 0 get    put %newPixel 0 get    put
			str n 1 add   newPixel 1 get    put
			str n 2 add   newPixel 2 get    put
		    }{
			% grayscale
			str n        .gray   rand .deltaPlusMinus.Gray mod plusMinus  0 255 range  put 
		    }ifelse
		} for

}def

/noiseFillColorThisColor2_MM{
    (noiseFillColorThisColor2: START) =
    10 dict begin
    /d# exch def

    /.color d# /Color get def

    /.x0 d# /X0 get def
    /.y0 d# /Y0 get def
    /.x1 d# /X1 get def
    /.y1 d# /Y1 get def
    /.scale d# /Scale get def

    d# /Interpolate known{
	/.interpolate d# /Interpolate get def
    }{
	/.interpolate false def
    }ifelse


    % Add 40 to buffer fill
    /width x1 x0 sub 50 add .scale mul cvi def
    /height y1 y0 sub 50 add .scale mul cvi def

    width =
    height =
    
    .color{
	/.blue d# /Blue get def
	/.green d# /Green get def
	/.red d# /Red get def
	/.deltaPlusMinus.R d# /DeltaPlusMinus.R get def
	/.deltaPlusMinus.G d# /DeltaPlusMinus.G get def
	/.deltaPlusMinus.B d# /DeltaPlusMinus.B get def
    }{
	/.gray d# /Gray get def
	/.deltaPlusMinus.Gray d# /DeltaPlusMinus.Gray get def
    }ifelse

    %/stringLength height width add 2 div dup mul 3 mul 3 add cvi def
    .color{
        /stringLength height width mul 3 mul  def
	/DeviceRGB setcolorspace
	/decode [0 1 0 1 0 1] def
    }{
	/DeviceGray setcolorspace
        /stringLength height width mul def
	/decode [0 1] def
    }ifelse

    /str stringLength  string def

    gsave
    .x0 25 sub .y0 25 sub translate


    %/DeviceRGB setcolorspace
    {
    << % Start image dictionary
	/ImageType 1
	/Width width
	/Height height
	/BitsPerComponent 8
	/Interpolate .interpolate
	/Decode decode  % Decode color values in normal way
	/ImageMatrix [.scale 0 0 .scale 0 0]
	/DataSource
	{
	    image.source.RandomImage

	    d# /UseFilters get{
		    d# /Filters get ===
		    d# /Filters get{
			/f# exch def
			f# ===
			f# /UseThisFilter known =
			f# /UseThisFilter get{
			    (RUNNUNG) =
			    f# f# /FilterProc get exec
			    /str exch store
			}if
		    }forall
		    str
		    str str length 2 div cvi  get =
		    str str length 2 div cvi 1 add get =
		    str str length 2 div cvi 2 add get =
		}{
	        str
	    }ifelse
	} 
    >>
    image % Color Image
    }stopped{
	(ERROR - image) =
	$error /errorname get ===
	quit
    }if
    grestore
    end

} bind def


/color.PixelAt{
    2 dict begin
    /y exch def
    /x exch def

    %/iii y width mul    x  add 3 mul cvi def
    /iii width 3 mul y mul    x 3 mul add cvi def
    % () =
    % x =
    % y =
    % width =
    % height =
    % width 3 mul y mul =
    % iii =

    [
        str iii get 
        str iii 1 add get 
        str iii 2 add get
    ]
    end
}bind def


/filter.Color.Average{
    % Not edges
    x d ge
    y d ge
    and
    x width d sub lt
    and
    y height d sub lt
    and
    {
        /valR 0 def
        /valG 0 def
        /valB 0 def
	/jj 0 def
	/ii 0 def
	/rgb null def

        d neg 1 d {
            /jj exch store
            d neg 1 d {
                /ii exch store
                /rgb x ii add y jj add  color.PixelAt store
                /valR valR  rgb 0 get  add store
                /valG valG  rgb 1 get  add  store
                /valB valB  rgb 2 get  add  store
            }for
        }for
        [
            valR cvr size2 cvr div cvi
            valG cvr size2 cvr div cvi
            valB cvr size2 cvr div cvi
        ]
    }{
	% Edge pixel
        [
            str i get
            str i 1 add get
            str i 2 add get
        ]
    }ifelse
}def

/filter.Gray.Average{
    x d ge
    y d ge
    and
    x width d sub lt
    and
    y height d sub lt
    and
    {
        /sum 0 def
	/jj 0 def
	/ii 0 def

        d neg 1 d {
            /jj exch store
            d neg 1 d {

                /ii exch store

                /index    y jj add width mul    x add ii add def

                /sum sum str index get  add store
            }for
        }for

	sum size2 cvr div cvi % Return average
    }{
        str n get  % Return same value for edges
    }ifelse
}def


/filter.Gray.Median{
    x d ge
    y d ge
    and
    x width d sub lt
    and
    y height d sub lt
    and
    {

        /mid size2 2.0 div ceiling cvi def
        /sum 0 def
        /values size2 array def
	/jj 0 def
	/ii 0 def

        /valuesIndex 0 def
        d neg 1 d {
            /jj exch store
            d neg 1 d {
                /ii exch store
                /index    y jj add width mul    x add ii add def
                values valuesIndex str index get put
                /valuesIndex valuesIndex 1 add store
                /sum sum str index get  add store
            }for
        }for
        values quicksort
        values mid get
    }{
        str n get  % Return same value for edges
    }ifelse
}def

/filter.Gray.Generic{
    % Applies the supplied kernel matrix to the x,y pixel in the image
    x d ge
    y d ge
    and
    x width d sub lt
    and
    y height d sub lt
    and
    {
        /sum 0 def

	/jj 0 def
	/ii 0 def
        /matrixIndex 0 def

        d neg 1 d {
            /jj exch store
            d neg 1 d {
                /ii exch store
                /index    y jj add width mul    x add ii add def

                /pixelValue  str index get def
                
                /sum sum   pixelValue .kernelMatrix matrixIndex get    mul add store
                /matrixIndex matrixIndex 1 add store
            }for
        }for

        .normalize{
            sum .matrixSum div cvi
        }{
            sum cvi
        }ifelse

        /vvv exch def

        vvv .zmin lt{
            /.zmin vvv store 
        }if

        vvv .zmax gt{
            /.zmax vvv store 
        }if
        vvv

    }{
        str n get  % Return same value for edges
    }ifelse
}def



/kernel.Color.SingleColor{
    filterArgs# /Color get
}def

/filter.Color.2Stripes{
    filterArgs# /Vertical get{
	/axis x def
    }{
	/axis y def
    }ifelse
    
    axis .size mod .size 2 div lt{
	kernelArgs# /Color1 get
    }{
	kernelArgs# /Color2 get
    }ifelse
}def


/ZZZ_normalizeImageRange{
    () =
    (/normalizeImageRange START) =
    
    2 dict begin

    /normalizedImage newstr length string def
    
    /delta .zmax .zmin sub def
    0 1 newstr length 1 sub{
        /n exch def
         /v newstr n get def
         .zmin 0 lt{

             v .zmin sub cvr delta div 255 mul cvi 255 gt{
                 (QQUIT 1) =
                 quit
             }if
             normalizedImage n v .zmin abs add cvr delta div 255 mul cvi  put
         }{
             v .zmin sub cvr delta div 255 mul cvi 0 lt{
                 (QQUIT 2) =
                 (v=) =
                 v =
                 (.zmin =) =
                 .zmin =
                 (v .zmin sub = ) =
                 v .zmin sub =
                 quit
             }if
             normalizedImage n v .zmin add cvr delta div 255 mul cvi  put

         }ifelse
     }for


     normalizedImage
     end
}def

/sumMatrix{
    /sum 0 def
    {
        sum add /sum exch store
    }forall
    sum
}def



/filterHarness{
    (M) =
    (/filterharness START) =
    10 dict begin
    /ff# exch def
    /.zmax -99999 def
    /.zmin 99999 def
    
    /filterArgs# ff# /FilterArgs# get def

    ff# ===
    filterArgs# ===

    /.normalizeRange false def
    /.normalize false def
    
    filterArgs# /KernelMatrix known{
        filterArgs# /Size   filterArgs# /KernelMatrix get /Matrix get length sqrt cvi  put
        /.kernelMatrix   filterArgs# /KernelMatrix get  /Matrix get def

        filterArgs# /KernelMatrix get  /Normalize known{
            /.normalize filterArgs# /KernelMatrix get  /Normalize get def
            /.matrixSum .kernelMatrix sumMatrix def
            .matrixSum =
        }if

        filterArgs# /KernelMatrix get  /NormalizeRange known{
            /.normalizeRange filterArgs# /KernelMatrix get  /NormalizeRange get def
        }if
        
    }if

    filterArgs# ===
    
    filterArgs# /Size known{
	/.size filterArgs# /Size get def
	/size2 .size .size mul def
	/d .size 2 div cvi def
	(==================) =
    }if
    (IIII) =
    d =

    .normalizeRange{
        (NO 2) =
        /newstr str length array def
    }{
        (NO) =
        /newstr str length string def

    }ifelse

    (M) =

    /x 0 def
    /y 0 def
    /i 0 def

    /newPixel [1 2 3] def
    0 1 height 1 sub{
        /y exch store

        0 1 width 1 sub{
            /x exch store

	    .color{
		/i y width mul   x  add 3 mul cvi store
	    }{
		/i y width mul   x  add cvi store
	    }ifelse

            ff# /Filter get exec /newPixel  exch store

	    .color{
		newstr i         newPixel 0 get put
		newstr i 1 add   newPixel 1 get put
		newstr i 2 add   newPixel 2 get put
	    }{
		newstr i  newPixel  put
	    }ifelse
        }for
    }for

    (MIN MAX ) =
    .zmin =
    .zmax =

    .normalizeRange{
        (NORMALIZING) =
        normalizeImageRange
    }{
        newstr
    }ifelse
    %newstr
    end
}bind def

(B) =

/image.generator.Noise{ % path defined
    (/image.generator.Noise) =
    1 dict begin
    /d# exch def
    d# /Angle known{
	d# /Angle get rotate
    }if
    bbox.Show
    pathbbox
    /y1 exch cvi def
    /x1 exch cvi def
    /y0 exch cvi def
    /x0 exch cvi def

    d# /X0 x0 put
    d# /Y0 y0 put 
    d# /X1 x1 put
    d# /Y1 y1 put

    gsave
    clip
    d# noiseFillColorThisColor2_MM
    %d# noiseFillColorThisColor2
    grestore
    end
}bind def




10 10 translate
newpath
100 100 moveto
100 0 rlineto
100 100 rlineto
100 0 rlineto
0 200 rlineto
-100 100 rlineto
-134 -45 rlineto
-100 100 rlineto
closepath

 gsave
 % Rotate rotate
 % bbox.Show
 grestore

% gsave
% stroke
% grestore






    <<
	gsave
    /UseFilters true
    /Angle Rotate
    /Interpolate true
    
    /Filters[
	<<
	    /UseThisFilter false
	    /Filter{
		kernel.Color.SingleColor
	    }
	    /FilterArgs#
	    <<
		/Color [100 0 0]
	    >>
	    /FilterProc {
		filterHarness
	    }
	>>

	<<
	    /UseThisFilter false
	    /Filter{
		filter.Color.2Stripes
	    }
	    /FilterArgs#
	    <<
		/Size 2
		/Color1 [0 255 0 0]
		/Color2 [255 0  0]
		/Vertical true
	    >>
	    /FilterProc {
		filterHarness
	    }
	>>
	<<
	    /UseThisFilter false
	    /Filter{
		filter.Color.Average
	    }
	    /FilterArgs#
	    <<
		/Size 3
	    >>
	    /FilterProc {
		filterHarness
	    }
	>>
    ]
    /Scale .8
    /Color true
    /Red 255
    %/Green 128
    /Green 255
    %/Blue 100
    /Blue 255
    /DeltaPlusMinus.R 1
    /DeltaPlusMinus.G 1
    /DeltaPlusMinus.B 199
>>
image.generator.Noise
grestore




showpage



10 setlinewidth
10 10 translate
newpath
100 100 moveto
100 0 rlineto
120 120 rlineto
100 0 rlineto

 100 100 rlineto
 -100 40 rlineto
 -100  200 rlineto
 -100 100 rlineto
 closepath
 gsave
% stroke
 grestore
gsave

/pixel3{ %str w h
    5 dict begin
    /.j exch def
    /.i exch def
    /.h exch def
    /.w exch def
    /.str exch def

    .w .h mul .str length ne{
        (/pixel: Size error) /rangeerror signalerror
        }if

    .str .w .j mul .i add get
     end
}bind def



/averageFilter.Gray{ % Assumes str .w .h x y size from /averageFilterGray
    2 dict begin
    /d .size 2 div cvi def

    x d ge
    y d ge
    and
    x .w d sub lt
    and
    y .h d sub lt
    and
    {
        /val 0 def
        d neg 1 d{
            /j exch def
            d neg 1 d{
                /i exch def
                /val val   .str .w .h x i add y j add pixel add store
            }for
        }for
        val .size .size mul div cvi
    }{
        str .w .h x y pixel cvi
    }ifelse
    end
}def

/averageFilter.Gray{ % w h str size
    1 dict begin
    /.size exch def
    /.h exch def
    /.w exch def
    /.str exch def

    /newstr .str length string def

    0 1 .h 1 sub{
        /y exch def
        
         0 1 .w 1 sub{
             /x exch def
             newstr y .w mul x add
             averageFilter.Gray
             put
         }for
    }for
    
    newstr
    end
}bind def



<<
    /Angle Rotate
    /Interpolate false

    /UseFilters true
    /Filters[
	<<
	    /UseThisFilter false
	    /FilterProc {
		filterHarness
	    }
	    /Filter{
		filter.Gray.Generic
	    }
	    /FilterArgs#
	    <<
                % OK                 /KernelMatrix LowPass_KernelMatrix_3
                % OK                 /KernelMatrix HighPass_KernelMatrix_3 
                % OK                 /KernelMatrix Laplacian_KernelMatrix_3
                % OK                 /KernelMatrix Edge_3
                % OK/KernelMatrix Sharpen_KernelMatrix_3
                % OK
                /KernelMatrix      GaussingBlur_KernelMatrix_5
                % OK                 /KernelMatrix GaussingBlur_KernelMatrix_3
	    >>
	>>
        <<
	    /UseThisFilter false
	    /FilterProc {
		filterHarness
	    }
	    /Filter{
		filter.Gray.Median
	    }
	    /FilterArgs#
	    <<
		/Size 3
	    >>
	>>
        
        <<
	    /UseThisFilter true
	    /FilterProc {
		filterHarness
	    }
	    /Filter{
	        filter.Gray.Average
	    }
	    /FilterArgs#
	    <<
		/Size 3
	    >>
	>>
    ]

    /Color false
    /Gray 128
    /DeltaPlusMinus.Gray 20
    /Scale .9
>>
image.generator.Noise
grestore

gsave

grestore

gsave
%bbox.Show
grestore
% gsave
 .2 .setfillconstantalpha % FILL opacity
  0 1 0 setrgbcolor
  fill
  grestore
showpage

% gsave
% 0 1 1 setrgbcolor
% bbox.Show
% grestore

% gsave
% 0 1 0 setrgbcolor stroke
% grestore

% gsave
% 2 setlinewidth
% 1 0 0 setrgbcolor
% bbox.Show2
% grestore


showpage



Shape
1 setlinejoin
0 0 1 setrgbcolor
% gsave
% .1 .setstrokeconstantalpha  % stroke opacity
% 2 setlinewidth
% stroke
% grestore


/alpha 0.2 def

5 1 11{
    /n exch def
    gsave
    alpha .setstrokeconstantalpha  % stroke opacity
    n setlinewidth
    stroke
    grestore
    /alpha alpha .01 sub store
}for

gsave
0.7 .setfillconstantalpha
1 0 0 setrgbcolor
fill
grestore

showpage





Shape

gsave
stroke
grestore
showpage


Shape
1 0 0 setrgbcolor

gsave
{%moveto Push x y; execute move

    = =
}
{%lineto Push x y; execute line

    = =
}
{%curveto Push x1 y1 x2 y2 x3 y3; execute curve
}
{%closepath Execute close
}
pathforall
grestore

stroke
showpage


gsave
2 2 scale
/Helvetica-Bold findfont 10 scalefont setfont

Shape
gsave
clip

newpath
/a {300 rand exch mod} def
/b {300 rand exch mod} def
/c {300 rand exch mod} def
/d {300 rand exch mod} def
/e {300 rand exch mod} def
/f {300 rand exch mod} def
/note {moveto (q) show} def

.5 setlinewidth
173417 srand
/Sonata findfont 10 scalefont setfont

.5 .setstrokeconstantalpha  
100{
    gsave
    128 rand 128 mod add 255.0 div   0 rand 255 mod 255.0 div   128 rand 128 mod add 255.0 div   setrgbcolor

 %   rand 30 mod rotate
    3 setlinewidth
    rand 1 setlinewidth
    %0 setlinewidth
    %  0 0 moveto
    a b moveto
    %10 {a b c d e f curveto} repeat
    10 {a b lineto} repeat

    gsave
    .1 .setstrokeconstantalpha
    4 setlinewidth
    stroke
    grestore


    grestore
}repeat
%{pop pop}{pop pop}{note note note}{} pathforall stroke

grestore

newpath
0 0 moveto
500 500 rlineto
stroke

100 100 translate
100 100 10 dot
fill



showpage


Shape
gsave
bbox.Show
grestore

gsave
pathbbox
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def

newpath
x1 y1 moveto
10 10 rlineto
stroke
grestore

gsave
currentpoint =
grestore

gsave
stroke
grestore
gsave
bbox.DrawCenterOf
grestore



showpage

grestore
grestore
newpath
100 100 translate
%0 1 0 setrgbcolor
50 100 10 dot
showpage

