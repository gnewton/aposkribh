%(ZZZ init.ps START) =

/aposkribh.libraryLoader_VERBOSE where not{
    /aposkribh.libraryLoader_VERBOSE true def
}{
    pop % throw away the found dict
}ifelse

/aposkribh.libraryLoader_VERBOSE_LOADING_ONLY where not{
    /aposkribh.libraryLoader_VERBOSE_LOADING_ONLY true def
}{
    pop % throw away the found dict
}ifelse

/aposkribh.run{  %Applies 'run' on array of strings/filenames
     count 2 lt{
         (/aposkribh.run: Need 2 args: string-filename []string) /stackunderflow signalerror
     }if 
     0 index type /arraytype ne{
         (/aposkribh.run: Arg0 Not []stringtype) /typecheck signalerror
     }if
     1 index type /stringtype ne{
         (/aposkribh.run: Arg1 Not stringtype (filename)) /typecheck signalerror
     }if
     %%

     /files exch def
     /baseFile exch def

     files
     {
         /filename exch def
         aposkribh.libraryLoader_VERBOSE{
             %() =
             %(*** aposkribh.run: ) baseFile concatstrings (: ) concatstrings filename concatstrings =
         }if
         filename run
    }forall

}bind def

/aposkribh.append{ % value array -> array with value added to end
    count 2 lt{
        (/append: Needs 2 args, any, array) /stackunderflow signalerror
    }def
    1 index type /arraytype ne{
        (/append: 2nd arg not /arraytype) /typecheck
    }if
    %%%
    
    2 dict begin
    /_v exch def
    /_a exch def
        
    /$newArray _a length 1 add array def

    0 1 _a length 1 sub{
        /i exch def
        $newArray i _a i get  put
    }for

    $newArray _a length _v put

    $newArray
    end
}bind def

/aposkribh.cat{ % array[strings] -> string
    count 0 eq{
        (/cat: Needs 1 arg: array[strings]) /stackunderflow signalerror
    }def
    0 index type /arraytype ne{
        (/cat: Arg not /arraytype) /typecheck
    }if
    %%%
    1 dict begin
    
    /_a exch def
    /delim ( - ) def
    /$s () def

    0 1 _a length 1 sub{
        /i exch def
        i 0 ne{
            /$s $s delim concatstrings store
        }if
        /$s $s _a i get concatstrings store
    }for

    $s
    end

}bind def



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% All files start with this %%%%%%%%%
% filename, array of to-be-laoded filenames; on stack

0 index type /arraytype ne{
    0 index type =
    (init.ps: First arg not /stringtype) /typecheck signalerror
}if

1 index type /stringtype ne{
    1 index type =
    (init.ps: 2nd arg not /stringtype) /typecheck signalerror
}if

/psfilenames exch def
/filename exch def

/aposkribh.PSFile where not{
    /aposkribh.PSFile 1 array def
    aposkribh.PSFile 0 filename put
    aposkribh.libraryLoader_VERBOSE{
        aposkribh.libraryLoader_VERBOSE_LOADING_ONLY not{
            aposkribh.PSFile aposkribh.cat ( START) concatstrings =
        }if
    }if
}{
    pop
    /aposkribh.PSFile aposkribh.PSFile filename aposkribh.append store
    aposkribh.libraryLoader_VERBOSE{
        aposkribh.libraryLoader_VERBOSE_LOADING_ONLY not{
            aposkribh.PSFile aposkribh.cat ( START) concatstrings =
        }if
    }if
}ifelse

(HELLO) psfilenames aposkribh.run

currentdict /psfilenames undef
currentdict /filename undef


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


/aposkribh.unappend{ % array -> array with last element removed
    count 0 eq{
        (/unappend: Needs 1 arg: array) /stackunderflow signalerror
    }def
    0 index type /arraytype ne{
        (/unappend: Arg not /arraytype) /typecheck
    }if
    %
    1 dict begin
    /_a exch def

    _a length 0 eq{
        _a % Return empty []
    }{
        /$newArray _a length 1 sub array def

        0 1 _a length 2 sub{
            /i exch def
            $newArray i _a i get  put
        }for

        $newArray
    }ifelse
    
    end

}bind def





/aposkribh.PSFile,LOG{

}bind def

/aposkribh.PSFile.END{
    aposkribh.libraryLoader_VERBOSE{
        aposkribh.libraryLoader_VERBOSE_LOADING_ONLY not{
            aposkribh.PSFile aposkribh.cat ( --END) concatstrings =
        }if
        /aposkribh.PSFile aposkribh.PSFile aposkribh.unappend store

        aposkribh.PSFile length 0 eq{
            () =
        }if
    }if
}bind def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This is run




count 0 ne{
    (--) =
    stack
    (--) =
    (init.ps: stack is not empty) /stackunderflow signalerror
}if

%( ZZZ init.ps END) =
