
/aposkribh.test# where not{

    /aposkribh.test# 20 dict def

    aposkribh.test# begin

    /aposkribh.StopOnFail where not{
        /aposkribh.StopOnFail true def
    }if

    /aposkribh.Testing where not{
        /aposkribh.Testing true def
    }if


    
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    /runTest{ % bool testName ->. (nothing)
        count 2 lt{
            (/runTest less than 2 args) /stackunderflow signalerror
        }if
        
        0 index type /stringtype ne{
            (/runTest first arg not string) /typecheck signalerror
        }if

        1 index type /booleantype ne{
            (/runTest second arg not boolean) /typecheck signalerror
        }if

        %%%%%%%%%%%%%%
        2 dict begin
        
        /_testName exch def
        {
            mark (Pass: ) _testName strcatmark =
        }
        {
            mark (Fail: ) _testName strcatmark =
            aposkribh.StopOnFail{
                quit
            }if
        }ifelse
        end
    }bind def



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    /assertError{% expectedError {stuff-to-exec} (msg) -> bool
        count 2 lt{
            (/assertError less than 2 args) /stackunderflow signalerror
        }if
        0 index type /nametype ne{
            (/assertError: First arg not nametype) /typecheck signalerror
        }if

        1 index type /arraytype ne{
            (/assertError: Second arg not array) /typecheck signalerror
        }if

        %%%%%
        3 dict begin
        /expectedError exch def
        {
            exec
        }stopped{
            /actualError $error /errorname get def

            expectedError actualError eq{
                mark (OK) (% AssertError) verbose2
                true
            }{
                mark (actualError does not match expected error) =
                actualError =
                expectedError =
                false
                aposkribh.StopOnFail{
                    quit
                }if
            }ifelse
        }{
            mark (assertError: should be an error) verbose2
            false
        }ifelse
        end
    }bind def


    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    /assertNotError{ % {stuff-to-exec} (msg) -> bool
        count 2 lt{
            (/assertNotError less than 2 args) /stackunderflow signalerror
        }if
        {
            exec
        }stopped{
            mark (assertNotError: should NOT be an error) verbose2
            (ERROR=) =
            $error /errorname get =
            false
        }{
            mark (OK) (% AssertNotError) verbose2
            true
        }ifelse
    }bind def

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    /assertValues{ % {stuff-to-exec} [array of expected values on stack] -> bool
        count 2 lt{
            (/assertValues less than 3 args) /stackunderflow signalerror
        }if
        0 index type /arraytype ne{
            (/assertValues first arg not array) /typecheck signalerror
        }if

        1 index type /arraytype ne{
            (/assertValues Second arg not array) /typecheck signalerror
        }if
        
        /_expectedValuesArray exch def
        dup cvlit /procString exch def
        %/_procName exch def
        {
            exec
        }stopped{
            (FAIL) =
            _procName =
            procString ===
            false
        }{
            aposkribh.primatives# begin
            _expectedValuesArray arrayEqualsStack % results left on stack (bool)
            end
        }ifelse
    }bind def



    
    /runTests.Errors{ % array of {{proc test} msg}
        5 dict begin
        /_a exch def
        _a{
            exec
            /expectedError exch def
            /msg exch def
            /tproc exch def
            {
                clear
                tproc
            } expectedError assertError
            msg  runTest
        }forall
    end
    }bind def

    /runTests.NoErrors{ % array of '{{proc test} msg}'
        5 dict begin
        /_a exch def
        _a{
            exec
            /msg exch def
            /tproc exch def
            {
                clear
                tproc
            }assertNotError msg runTest
        }forall
        end
    }def


    /runTests.NoErrorsWithValues{ % array of '{{proc test} msg}'
        5 dict begin
        /_a exch def
        _a{
            exec % pushes array entry items onto stack
            /msg exch def
            /expectedValuesArray exch def
            
            /tproc exch def
            {
                clear
                tproc
            }  expectedValuesArray assertValues msg runTest
        }forall
        end
    }def

    /runTests.StackReturn{ % array of '{{proc test} [expected stack] msg}'
        5 dict begin
        /_a exch def
        _a{
            exec
            /msg exch def
            /expectedStack exch def
            /tproc exch def
            {
                clear
                tproc
            }assertNotError msg runTest
        }forall
        end
    }def

    end  % aposkribh_test#
}if
