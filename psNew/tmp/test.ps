
(globals.ps) run

/aposkribh.test# where not{

    /aposkribh.test# 20 dict def

    aposkribh.test# begin

    /aposkribh.StopOnFail where not{
        /aposkribh.StopOnFail true def
    }if

    /aposkribh.Testing where not{
        /aposkribh.Testing true def
    }if


    
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    /runTest{ % bool testName ->. (nothing)
        count 2 lt{
            (/runTest less than 2 args) /stackunderflow signalerror
        }if
        
        0 index type /stringtype ne{
            (/runTest first arg not string) /typecheck signalerror
        }if

        1 index type /booleantype ne{
            (/runTest second arg not boolean) /typecheck signalerror
        }if

        %%%%%%%%%%%%%%
        2 dict begin
        
        /_testName exch def
        /_passedTest exch def
        
        _passedTest{
            aposkribh.TEST_SHOW_PASSES{
                mark (Pass: ) _testName strcatmark =
            }if
        }
        {
            mark (Fail: ) _testName strcatmark =
            aposkribh.StopOnFail{
                quit
            }if
        }ifelse
        end
    }bind def



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    /assertError{% expectedError {stuff-to-exec}  -> bool
        count 2 lt{
            (/assertError less than 2 args) /stackunderflow signalerror
        }if
        0 index type /nametype ne{
            (/assertError: First arg not nametype) /typecheck signalerror
        }if

        1 index type /arraytype ne{
            (/assertError: Second arg not array) /typecheck signalerror
        }if

        %%%%%
        3 dict begin
        /expectedError exch def
        {
            exec
        }stopped{
            /actualError $error /errorname get def

            expectedError actualError eq{
                mark (OK) (% AssertError) verbose2
                true
            }{
                mark (actualError does not match expected error) =
                actualError =
                expectedError =
                false
                aposkribh.StopOnFail{
                    quit
                }if
            }ifelse
        }{
            mark (assertError: should be an error) verbose2
            false
        }ifelse
        end
    }bind def



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    /assertValues{ % {stuff-to-exec} [array of expected values on stack] -> bool
        count 2 lt{
            (/assertValues less than 3 args) /stackunderflow signalerror
        }if
        0 index type /arraytype ne{
            (/assertValues first arg not array) /typecheck signalerror
        }if

        1 index type /arraytype ne{
            (/assertValues Second arg not array) /typecheck signalerror
        }if

        %%%%%
        3 dict begin 
        /_expectedValuesArray exch def
        dup cvlit /procString exch def
        %/_procName exch def
        {
            exec
        }stopped{
            (FAIL) =
            _procName =
            procString ===
            false
        }{
            aposkribh.primatives# begin
            _expectedValuesArray arrayEqualsStack % results left on stack (bool)
            end
        }ifelse
        end
    }bind def



    
    /runTests.ExpectErrors{ % array of {{proc test} msg}
        count 0 eq{
            (/runTests.ExpectErrors less than 1 arg) /stackunderflow signalerror
        }if
        0 index type /arraytype ne{
            (/runTests.ExpectErrors first arg not array) /typecheck signalerror
        }if
        
        5 dict begin
        /_a exch def
        _a{
            exec
            /expectedError exch def
            expectedError type /nametype ne{
                (/runTests.ExpectErrors expectedError not nametype) /typecheck signalerror
            }if
            /msg exch def
            msg type /stringtype ne{
                (/runTests.ExpectErrors msg not stringtype) /typecheck signalerror
            }if
            /tproc exch def
            {
                clear
                tproc
            } expectedError assertError
            msg  runTest
        }forall
    end
    }bind def

    /runTests.ExpectedValues{ % array of '{{proc test} msg}'
        5 dict begin
        /_a exch def
        _a{
            exec % pushes array entry items onto stack
            /msg exch def
            /expectedValuesArray exch def
            
            /tproc exch def
            {
                clear
                tproc
            }  expectedValuesArray assertValues msg runTest
        }forall
        end
    }def


    end  % aposkribh_test#
}{
    pop % get rid of found dict 
}ifelse
