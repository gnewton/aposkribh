
(globals.ps) run

% Should not rely on any primative.ps
%
/aposkribh.test# where not{

    /aposkribh.test# 20 dict def

    aposkribh.test# begin

    /aposkribh.StopOnFail where not{
        /aposkribh.StopOnFail true def
    }if

    /aposkribh.Testing where not{
        /aposkribh.Testing true def
    }if

    /isProc{
        2 dict begin
        /n exch  def
        n count  ge{
            (/isProc: Stack too small) /stackunderflow signalerror
        }if
        n index type /arraytype ne{
            n  index cvlit  ===
            n  index type =
            (/isProc: Not executable proc) /typecheck signalerror
        }if
        end
    }bind def

    % simple tests
    /test.F{ % { } : proc should return true
        0 isProc
        [false] test.V
    }bind def
    
    /test.T{ % { } : proc should return false
        0 isProc
        [true] test.V
    }bind def
    

    /test.V{ % {} [expected values left on stack] : proc should run and return specific values on stack
        1 isProc
        10 dict begin
        /_expectedStack exch def
        %
        
        dup /procAsString exch cvlit def

        aposkribh.VERBOSE_TEST{
            () =
            (test.V) =
            procAsString ===
        }if
        
        {
            /proc exch def
            clear
            {proc} exec
        }stopped{
            $error /errorname get
            (Fail: Error: Should run OK and return results) =
            procAsString ===
            _expectedStack ===
            (/V: FAIL ) exch signalerror
        }{
            _expectedStack arraySameAsStack not{
                (Fail: V: Results stack does not match) =
                procAsString ===
                _expectedStack ===
            }if
        }ifelse
        end
        clear
    }bind def

    /test.E{ % { } /errortype : Should run and throw a specific error
        1 isProc
        10 dict begin
        /_expectedError exch def

        dup /procAsString exch cvlit def

        aposkribh.VERBOSE_TEST{
            () =
            (test.E) =
            procAsString ===
        }if

        {
            /d exch def
            clear
            {d} exec
        }stopped{
            /actualError $error /errorname get def
            
            actualError _expectedError ne{
                (FAIL: Expected error but wrong error) =
                procAsString ===
                actualError =
                _expectedError =
                (/test.E: ) /invalidexit signalerror
            }if
        }{
            (FAIL: Expected error but no error) =
            procAsString ===
            _expectedError =
            (/test.E: ) /invalidexit signalerror
        }ifelse
        clear
    }bind def


    end  % aposkribh_test#
}{
    pop % get rid of found dict 
}ifelse

