
(globals.ps) run

/aposkribh.test# where not{

    /aposkribh.test# 20 dict def

    aposkribh.test# begin

    /aposkribh.StopOnFail where not{
        /aposkribh.StopOnFail true def
    }if

    /aposkribh.Testing where not{
        /aposkribh.Testing true def
    }if


    
    




    % simple tests
    /test.F{ % { }
        [false] test.V
    }bind def
    
    /test.T{ % { }
        [true] test.V
    }bind def
    

    /test.V{ % {} [expected values left on stack]
        10 dict begin
        /_expectedStack exch def
        %
        
        dup /procAsString exch cvlit def

        {
            /proc exch def
            clear
            {proc} exec
            %exec
        }stopped{
            $error /errorname get
            (Fail: Error: Should run OK and return results) =
            procAsString ===
            _expectedStack ===
            (/V: FAIL ) exch signalerror
        }{
            _expectedStack arraySameAsStack not{
                (Fail: V: Results stack does not match) =
                procAsString ===
                _expectedStack ===
            }if
        }ifelse
        end
        clear
    }bind def

    /test.E{ % { } /errortype
        % Runs proc and expects particular error
        10 dict begin
        /_expectedError exch def

        dup /procAsString exch cvlit def

        {
            /d exch def
            clear
            {d} exec
        }stopped{
            /actualError $error /errorname get def
            
            actualError _expectedError ne{
                (FAIL: Expected error but wrong error) =
                procAsString ===
                actualError =
                _expectedError =
                quit
            }if
        }{
            (FAIL: Expected error but no error) =
            procAsString ===
            _expectedError =
            quit
        }ifelse
        clear
    }bind def


    end  % aposkribh_test#
}{
    pop % get rid of found dict 
}ifelse
