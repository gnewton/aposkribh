
(assert.ps) run

aposkribh.assert#
begin


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Should not FAIL
[
    (1 1 assertAtLeastNArgs)
    ((m) 1  assertAtLeastNArgs)
    (77 66  2 assertAtLeastNArgs)
    (0 assertAtLeastNArgs)


    (0 assert0IsPositiveInteger)
    (100 assert0IsPositiveInteger)

    (33 1 assertStackIsBigEnoughFromArg0)
    ((mm) 33 2 assertStackIsBigEnoughFromArg0)
    (44 (mm) 33 2 assertStackIsBigEnoughFromArg0)
    
    (10   0 assertInteger)
     (0    0 assertInteger)
     (-100 0 assertInteger)
     ((foo) -100 0 assertInteger)
     (44 (foo) -100 2 assertInteger)
     ( {} 0 assertProc  )
     ( {} 42 1 assertProc  )

     ( (foo) 42 1 assertString  )
     ( 34 (foo)  0 assertString  )
     ( (foo) 42.3 0 assertReal  )
     ( (foo) 42.3 0 assertNumber  )
     ( (foo) 42 0 assertNumber  )

     ( [] 0 assertArray )


]
% forall
{
    % stopped
    {
        /proc exch def
        clear
        proc cvx
        exec
    }stopped{ % if
        (FAIL: This should run successfully but did not:) =
        proc =
        $error /errorname get =
        $error /command get =
        (assert_test.ps) /undefined signalerror
    }if
}forall



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Should FAIL
[

    [ (assertAtLeastNArgs)  /stackunderflow ]
    [ (-1 assertAtLeastNArgs) /rangecheck ]
    [ (1 assertAtLeastNArgs)  /stackunderflow ]


    [ ((foo) assert0IsPositiveInteger)   /typecheck      ]
    [ (-1 assert0IsPositiveInteger)      /rangecheck      ]
    [ (/stringtype  assert0IsPositiveInteger)    /typecheck      ]
    [ (45.5 assert0IsPositiveInteger)    /typecheck      ]
    [ (<<>> assert0IsPositiveInteger)    /typecheck      ]
    [ ([22] assert0IsPositiveInteger)    /typecheck      ]
    [ ([] assert0IsPositiveInteger)    /typecheck      ]
    [ (assert0IsPositiveInteger)      /stackunderflow     ]
    [ (mark  assert0IsPositiveInteger)    /typecheck      ]
    [ (null assert0IsPositiveInteger)    /typecheck      ]
    [ (true assert0IsPositiveInteger)    /typecheck      ]
    [ ({}  assert0IsPositiveInteger)    /typecheck      ]

    [ (assertStackIsBigEnoughFromArg0)    /stackunderflow ]
    [ (2 assertStackIsBigEnoughFromArg0)    /stackunderflow ]

    [ ( assertInteger)                  /stackunderflow ]
    [ ( 22 2 assertInteger)             /stackunderflow ]
    [ ( (foo) assertInteger)            /typecheck      ]
    [ ( 22.3 0 assertInteger)           /typecheck      ]
    [ ( 44 (foo) -100 3 assertInteger)  /stackunderflow ]
    [ ( 44 (foo) -100 1 assertInteger)  /typecheck      ]
    [ ( 44 (foo) -100 -1 assertInteger) /rangecheck     ]
    [ ( (foo) 0 assertInteger)          /typecheck      ]

    [ ( assertProc  )           /stackunderflow ]
    [ ( {} 42 0 assertProc  )           /typecheck ]
    [ ( 42 [0] 0 assertProc  ) /typecheck ]

    [ ( assertString  ) /stackunderflow ]
    [ ( 0 assertString  ) /stackunderflow  ]
    [ ( 42 0 assertString  ) /typecheck ]
    [ ( 42.2 0 assertString  ) /typecheck ]
    [ ( true 0 assertString  ) /typecheck ]
    [ ( <<>> 0 assertString  ) /typecheck ]
    [ ( null 0 assertString  ) /typecheck ]
    [ ( /stringtype 0 assertString  ) /typecheck ]
    [ ( {}  0 assertString  ) /typecheck ]
    [ ( mark  0 assertString  ) /typecheck ]

    [ ( assertArray ) /stackunderflow ] 
    [ ( 0 assertArray ) /stackunderflow ] 
    [ ( 3 0 assertArray ) /typecheck ]
    [ ( 3.0 0 assertArray ) /typecheck ]
    [ ( <<>> 0 assertArray ) /typecheck ]
    [ ( (foo) 0 assertArray ) /typecheck ]
    [ ( [ 0 assertArray ) /typecheck ]
    [ ( mark 0 assertArray ) /typecheck ]
    [ ( null 0 assertArray ) /typecheck ]
    [ ( true 0 assertArray ) /typecheck ]
    [ ( /integertype 0 assertArray ) /typecheck ] 
]
{ % forall
    /proc null def
    /expecterError null def
    { % stopped
        /a exch store
        /proc a 0 get store
        /expectedError a 1 get store
        clear
        proc cvx
        exec
    }stopped{ % ifelse
        /actualError $error /errorname get def

        actualError expectedError ne{ % if
            (FAIL: This should not run successfully but should throw a error specific error: Threw wrong error.) =
            (Expected error: /) expectedError expectedError length string cvs concatstrings =
            (  Actual error: /) actualError 20 string cvs concatstrings =
            (% --> {) proc concatstrings ( }) concatstrings =
            $error /command get =
            (assert_test.ps) /undefined signalerror
        }if
    }{
        () =
        (FAIL: This should not run successfully but should throw an error. Did not throw an error.) =
        (% --> {) proc concatstrings ( }) concatstrings =
        (assert_test.ps) /undefined signalerror
    }ifelse
}forall



end
