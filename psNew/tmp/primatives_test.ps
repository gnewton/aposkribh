

(primatives.ps) run

(test.ps) run

aposkribh.primatives# begin
aposkribh.test# begin

/test.primatives# 20 dict def

test.primatives# begin
/checkArgs.Tests{
    (%% Negative tests) =
    [
        { {32.2 [/integertype] (checkArgs)  checkArgs}  (/checkArgs: /real instead of /integertype) /typecheck }
        { {[/integertype] (checkArgs) checkArgs      }  (/checkArgs: Want 1 integer; stack empty) /stackunderflow}
        { {1 [/stringtype] (procName) checkArgs      }  (/checkArgs: Actual 1 arg not string) /typecheck}
        { {(foo)  <<>> (checkArgs) checkArgs         }  (/checkArgs: 0 arg not array) /typecheck}
        { {(o) [/integertype] (procName) checkArgs   }  (/checkArgs: Actual 1 arg not integer) /typecheck}
    ] runTests.Errors

    (%% Positive tests) =
    [
        { {(foo) 32   [/integertype /stringtype] (procName) checkArgs} (/checkArgs: mmmm Actual 1 arg not integer) }
        { {[] (checkArgs) checkArgs                                   } (/checkArgs: No args in args type array)   }
    ] runTests.NoErrors


    
    (% END) =
}def % checkArgs.Tests




/strcatmark.Tests{
    
    % clear
    % {
    %     mark (a) (b) [/NStrings /marktype ] (strcatmark) checkArgs
    % }assertNotError
    % (/strcatmark: Handle marks) runTest

}def

/verbose2.Tests{

}def

/stack2array{

}def

/r2s.Tests{

}def

/n2s.Tests{

}def

/i2s.Tests{

}def

/strcat.Tests{

}def

/spaces.Test{

}def

/switch.Tests{

}def

/nswitch.Tests{

}def

/execClean.Tests{

}def

/memoize.Tests{

}def


end % test.primatives# begin


test.primatives# {
    exch =
    exec

}forall


end % aposkribh_test#
end % aposkribh_primatives# 


