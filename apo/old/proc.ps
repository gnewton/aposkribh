%!PS-Adobe-2.0 
%%
%%Creator:Glen Newton
%%Copyright: 2025 Glen Newton
%%%%%%%%%%%%%%



/proc.Registry#
<<
>>def

/proc.Template{
    <<
	/Args [] % Default implies no args
	% [
	%     [
	% 	[argtype0 argtype1] [returnTtpe0 returntype2]
	%     ]
       	%     [
	% 	[argtype0 argtype1] [returnTupe0]
	%     ]
	% ]

        /ArgsFailMessageGeneral ()
         /ArgsFailMessages
         [
             %(Arg0 message)
             %(Arg1 message
         ]
         
	/Proc {
            (%%%%%%%%%% /Proc not defined) /undefined signalerror
            
	}

	/Description {
            (% /Description not defined) /undefined signalerror
        }

	/Documentation{
            (% /Documentation not defined)/undefined signalerror
        }

        /SetProcAndArgs{
            /Proc exch def
            /Args exch def
        } 
    >>
}bind def

/proc.Register{
    count 2 lt{
        (ERROR: /proc.Register: Needs 2 args) /stackunderflow signalerror
    }if

    0 index type /dicttype ne{
        (ERROR: /proc.Register: First arg not /dicttype) /typecheck signalerror
    }if

    1 index type /nametype ne{
        (ERROR: /proc.Register: Second arg not /nametype) /typecheck signalerror
    }if
    %
    /_procDict# exch def
    /_name exch def
    %
    
    proc.Registry# _name known{
        (Proc name already exists in proc.Registry#: ) _name dup length string cvs concatstrings /dictfull   util.ERROR
    }if
    proc.Registry# _name _procDict# put
}bind def

/proc.New{
    2 dict begin
    dup
    /_name exch def

    /newProc 10 dict def
    proc.Template newProc copy pop
    newProc /Name _name put
    _name newProc proc.Register
    newProc
    end
}def

/proc.R{
    () log.Print
    (/proc.R START) log.Print

    5 dict begin
    /_f# exch def
    _f# [/Name /Args /Proc] (/R) util.dict.KeysMustExist

    (/proc.R: Checking args) log.Print

    % _f# /Args get proc.CheckArg not{
    %     (proc.R: One of the args missing or incorrect type) /typecheck signalerror
    % }if

    _f# /Args get proc.CheckArgs


    %(/proc.R: Starting proc: [) _f# /Name get dup length string cvs concatstrings (]) concatstrings log.Print
    _f# /Proc get exec

    %_f# /Args get proc.CheckResultsNumberAndType
    end

}bind def

/proc.CheckResultsNumberAndType{
    0 index type /arraytype ne{
        (/proc.CheckArgs: Arg0 not /arraytype) /typedef signalerror
    }if
    %
    
    /_argsResultsList exch def
    
    count /stackCount exch def
    /resultsLengthMatch false def

    /argsResults null def
    /results null def

    _argsResultsList{
        /argsResults exch store
        /results argsResults 1 get store
        results length 0 eq{
            /resultsLengthMatch true store
            exit
        }if
        stackCount args length  ge{
            /resultsLengthMatch true store
            exit
        }if
    }forall

    resultsLengthMatch not{
        (proc.CheckResultsNumberAndType: missing results on stack) /stackunderflow util.ERROR
    }if

    %%%%%% One arg length matches
    
    /resultsTypeMatch false def
    _argsResultsList{
        /argResults exch def
        /results argResults 1 get def

        args length 0 eq{
            /argsTypeMatch true store
            exit
        }if
        args util.StackMatchesArrayTypes {
            /argsTypeMatch true store
            exit
        }if
    }forall

    argsTypeMatch not{
        (proc.CheckArgs: arg(s) wrong type) /typecheck util.ERROR
    }if

}def

/proc.CheckArgs{
    0 index type /arraytype ne{
        (/proc.CheckArgs: Arg0 not /arraytype) /typedef signalerror
    }if
    %
    /_argsResultsList exch def
    
    count /stackCount exch def
    /argLengthMatch false def

    /argsResults null def
    /args null def

    _argsResultsList{
        /argsResults exch store
        /args argsResults 0 get store
        args length 0 eq{
            /argLengthMatch true store
            exit
        }if
        stackCount args length  ge{
            /argLengthMatch true store
            exit
        }if
    }forall

    argLengthMatch not{
        (proc.CheckArgs: needs more args) /stackunderflow util.ERROR
    }if

    %%%%%% One arg length matches
    
    /argsTypeMatch false def
    _argsResultsList{
        /argResults exch def
        /args argResults 0 get def

        args length 0 eq{
            /argsTypeMatch true store
            exit
        }if
        args util.StackMatchesArrayTypes {
            /argsTypeMatch true store
            exit
        }if
    }forall

    argsTypeMatch not{
        (proc.CheckArgs: arg(s) wrong type) /typecheck util.ERROR
    }if

    %%%%%% One args types matches

}bind def

/proc.RedefineWrapper{
    /_proc exch def
    /_args exch def

    _args ===
    constants.proc.RedefineWrapper.Flag not{
        _proc
    }{
        _args ===
        _args proc.CheckArgs
        _proc 5 sub 
    }ifelse
}bind def

