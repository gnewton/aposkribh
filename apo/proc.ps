%!PS-Adobe-2.0 
%%
%%Creator:Glen Newton
%%Copyright: 2025 Glen Newton
%%%%%%%%%%%%%%



/proc.Registry#
<<
>>def

/proc.Template{
    <<
	/Args [] % Default implies no args
	% [
	%     [
	% 	[argtype0 argtype1] [returnTtpe0 returntype2]
	%     ]
       	%     [
	% 	[argtype0 argtype1] [returnTupe0]
	%     ]
	% ]

        /ArgsFailMessageGeneral ()
         /ArgsFailMessages
         [
             %(Arg0 message)
             %(Arg1 message
         ]
         
	/Proc {
            (%%%%%%%%%% /Proc not defined) /undefined signalerror
            
	}

	/Description {
            (% /Description not defined) /undefined signalerror
        }

	/Documentation{
            (% /Documentation not defined)/undefined signalerror
        }
    >>
}bind def

/proc.Register{
    count =
    count 2 lt{
        (ERROR: /proc.Register: Needs 2 args) /stackunderflow signalerror
    }if
    (M) =    
    0 index type /dicttype ne{
        (ERROR: /proc.Register: First arg not /dicttype) /typecheck signalerror
    }if

    1 index type /nametype ne{
        (ERROR: /proc.Register: Second arg not /nametype) /typecheck signalerror
    }if
    %
    /_procDict# exch def
    /_name exch def
    %
    
    proc.Registry# _name known{
        (M) =
        (Proc name already exists in proc.Registry#: ) _name dup length string cvs concatstrings /dictfull signalerror
        quit
    }if
    proc.Registry# _name _procDict# put
}bind def

/proc.New{
    2 dict begin
    dup
    /_name exch def

    /newProc 10 dict def
    proc.Template newProc copy pop
    newProc /Name _name put
    _name newProc proc.Register
    newProc
    end
}def

/proc.R{
    () log.Print
    (/proc.R START) log.Print

    5 dict begin
    /_f# exch def
    _f# [/Name /Args /Proc] (/R) util.dict.KeysMustExist

    (/proc.R: Checking args) log.Print

    _f# /Args get proc.CheckArgs not{
        (proc.R: One of the args missing or incorrect type) /typecheck signalerror
    }if



    %(/proc.R: Starting proc: [) _f# /Name get dup length string cvs concatstrings (]) concatstrings log.Print
    _f# /Proc get exec

    end

}bind def


/proc.CheckArgs{
    0 index type /arraytype ne{
        (/proc.CheckArgs: Arg0 not /arraytype) /typedef signalerror
        pop
    }if
    %
    
    /ok false def
    {
     
        /argResultPairs exch def
        /args argResultPairs 0 get def
        args util.StackMatchesArrayTypes {
            /ok true def
            exit
        }if
    }forall
    ok 
}bind def

/proc.CheckArgs2{
    0 index type /arraytype ne{
        (/proc.CheckArgs: Arg0 not /arraytype) /typedef signalerror
    }if
    %
    /_argsResultsList exch def
    
    count /stackCount exch def
    /argLengthMatch false def

    /argsResults null def
    /args null def

    _argsResultsList{
        /argsResults exch store
        /args argsResults 0 get store
        args length 0 eq{
            (HELLOW) =
            /argLengthMatch true store
            exit
        }if
        args ===
        (A) =
        util.Stack
        (J) =
        stackCount =
        args length =
        stackCount args length  ge =
        stackCount args length  ge{
            /argLengthMatch true store
            (JJJJJJJJJJJJJJ) =
            exit
        }if
        (B) =
    }forall

    (C) =
    argLengthMatch =
    
    argLengthMatch not{
        (proc.CheckArgs2: needs more args) /stackunderflow util.ERROR
    }if

    %%%%%% One arg length matches
    
    /argsTypeMatch false def
    _args{
        /argResults exch def
        /args argResults 0 get def

        args length 0 eq{
            /argsTypeMatch true store
            exit
        }if
        args util.StackMatchesArrayTypes {
            /argsTypeMatch true store
            exit
        }if
    }forall

    argsTypeMatch not{
        (proc.CheckArgs2: arg(s) wrong type) /typecheck util.ERROR
    }if

    %%%%%% One args types matches

}bind def

/proc.RedefineWrapper{
    /_proc exch def
    /_args exch def

    _args ===
    constants.proc.RedefineWrapper.Flag not{
        _proc
    }{
        _args ===
        _args proc.CheckArgs2
        _proc 5 sub
    }ifelse
}bind def

