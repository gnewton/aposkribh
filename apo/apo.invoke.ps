%!PS-Adobe-2.0 
%%
%%Creator:Glen Newton
%%Copyright: 2025 Glen Newton
%%%%%%%%%%%%%%

/apo.invoke.checkargsandresults.Strict true def


/apo.invoke.Production{ % 0 - /Proc; 1 - nametype
    apo.invoke.Production.debug.Flag{
        log.debug.Debug+
        dup dup length string cvs /procName exch def
        (apo.invoke.Production)  (START proc= /) procName concatstrings log.debug.Print
    }if
    
    % Invokes proc directly
    apo.Procs# exch get exec

    apo.invoke.Production.debug.Flag{
        (apo.invoke.Production)  (END   proc= /) procName concatstrings log.debug.Print
        log.debug.Debug-
    }if
}bind def


/apo.invoke.ProductionWithChecks{
    % Invokes proc after checking args and verifying number and type of results on stack
    {
        apo.invoke.Production
    } apo.invoke.CheckArgsAndResults

}bind def



/apo.invoke.Test{
    % Needs /apo.Test# defined
    %
    (/apo.invoke.Test) /undefined signalerror
}bind def

/apo.invoke.TestAll{
    %
    (/apo.invoke.TestAll) /undefined signalerror
}bind def


/apo.invoke.CheckArgsAndResults{ % 0 - apo.invoke.Production; 1 - /Proc nametype
    apo.invoke.Production.debug.Flag{
        log.debug.Debug+
        (START) (apo.invoke.CheckArgsAndResults) log.debug.Print
    }if
    % Put the proc into an array
    /_proc 1 array def
    _proc 0 0 index put
    pop
    /_procName exch def
    
    _procName apo.ProcSignatures# exch known{ % Is there a signature definition for this Proc?
        ( ***** TODO: check args  ) (apo.invoke.CheckArgsAndResults) log.debug.Print
        % A - check args
        (PROC) =
        _procName =
        (--PROC) =
        _procName apo.ProcSignatures# exch get /listOfPossibleArgsAndResults exch  def

        (MMMMMMMMMMMMMMMMMM) =
        listOfPossibleArgsAndResults apo.invoke.checkArgs{
            (TRUE) =
            ===
        }if
        (MMMMMMMMMMMMMMMMMM) =
        
        % possibleArgsResults ==
        % B - run proc
        % C - check results
        (****** TODO: check results  ) (apo.invoke.CheckArgsAndResults) log.debug.Print
    }{
        % No signature: FIXXX This should just fail!
        apo.invoke.checkargsandresults.Strict{ % If strict, error, as is is required
            mark (/apo.invoke.CheckArgsAndResults: /) _procName dup length string cvs ( does not have a signature defined) apo.util.concatstringsToMark /undefined signalerror
        }if

    }ifelse

    % Execute the actual proc
    _proc 0 get
    exec

    apo.invoke.Production.debug.Flag{
        (END  ) (apo.invoke.CheckArgsAndResults) log.debug.Print
        log.debug.Debug-
    }if
}bind def

/apo.invoke.checkArgs{
    /argResultsList exch def

    /@matchingArgs [] def

    (------------------ apo.invoke.checkArgs) =
    argResultsList{
        /argsResults exch def
        argsResults 0 get
        apo.util.StackMatchesArrayTypes{
            /@matchingArgs argsResults 0 get   store
        }if
    }forall
    @matchingArgs length 0 gt{
        @matchingArgs true
    }{
        false
    }ifelse
}def


